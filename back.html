<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
/>

<!-- BACK -->
<div class="back">
  <!-- HEADER -->
  <div class="header">
    <!-- Custom Dark Mode Toggle -->
    <span class="toggle-custom-dark-mode tappable">
      <i class="fas fa-sun sun-icon"></i>
      <i class="fas fa-moon moon-icon"></i>
    </span>

    <!-- Settings Toggle -->
    <span class="toggle-settings-btn tappable">
      <i class="fas fa-cog"></i>
    </span>

    <!-- Audios -->
    {{#wordAudio}}
    <div class="{{Tags}}"><span class="audio">{{wordAudio}}</span></div>
    {{/wordAudio}} {{#sentenceAudio}}
    <div class="{{Tags}}">
      <span class="sentenceaudio">{{sentenceAudio}}</span>
    </div>
    {{/sentenceAudio}}

    <!-- Notes Toggle -->
    {{#notes}}
    <span class="toggle-notes tappable">
      <div class="toggle-notes-svg"></div>
    </span>
    {{/notes}}

    <!-- Image Toggle -->
    <span
      class="toggle-image-visibility show-btn tappable"
      style="display: none"
    >
      <i class="fas fa-image"></i>
    </span>

    <!-- Frequency Dropdown -->
    <div id="frequency">
      <div class="frequency-box tappable">
        <label class="freqbt" data-freq="{{freqSort}}">
          {{freqSort}} <i class="fas fa-chevron-down arrow"></i>
        </label>
        {{#frequency}}
        <div class="frequency-content">{{frequency}}</div>
        {{/frequency}}
      </div>
    </div>
  </div>
  <!-- /HEADER -->

  <!-- GRID LAYOUT -->
  <div class="grid-container">
    <!-- Word -->
    <div class="background-box tappable">
      <div id="word" class="pitch card-a">
        <span class="{{pitch}} {{Tags}}">
          <ruby>{{word}}<rt>{{reading}}</rt></ruby>
          <div id="position">{{pitchPosition}}</div>
          <div id="categories" class="tappable">{{pitch}}</div>
        </span>
      </div>
    </div>

    <!-- Picture -->
    <div class="picture-container {{Tags}} clickable-image tappable">
      {{picture}}

      <div class="toggle-image-visibility hide-btn tappable">
        <i class="fas fa-times"></i>
      </div>

      <div class="nav-arrow left tappable"></div>
      <div class="nav-arrow right tappable"></div>
    </div>
  </div>
  <!-- /GRID LAYOUT -->

  <!-- Lightbox -->
  <div class="lightbox" id="lightbox">
    <img id="lightbox-img" />
    <a href="#" class="close tappable"></a>
    <div class="lightbox-nav left tappable"></div>
    <div class="lightbox-nav right tappable"></div>
    <button id="show-all" class="lightbox-grid-toggle tappable">
      Show All
    </button>
  </div>

  <!-- Sentence -->
  <div class="sentence-container">
    <div id="sentence">
      <span id="formattedSentence" class="{{pitch}} tappable"></span>
    </div>
    <div id="sentenceEng" class="is-collapsed">{{sentenceEng}}</div>
  </div>

  <!-- Notes -->
  {{#notes}}
  <div id="notes" class="notes-panel is-collapsed">
    <div class="notes-counter"></div>
    <div class="toggle-area left-larger tappable"></div>
    <div class="toggle-area right-larger tappable"></div>
    <div class="toggle-area left tappable"></div>
    <div class="toggle-area right tappable"></div>
    <div class="notes-box">
      <span class="notes-raw">{{notes}}</span>
    </div>
  </div>
  {{/notes}}

  <!-- Selection Text -->
  {{#selectionText}}
  <div id="selectionText" class="card-b" data-type="selectionText">
    <div class="definition-box">
      <div class="dictionary-title">Selected Text</div>
      <div class="dictionary-counter"></div>
      <div class="toggle-area left-larger tappable"></div>
      <div class="toggle-area right-larger tappable"></div>
      <div class="toggle-area left tappable"></div>
      <div class="toggle-area right tappable"></div>
      <span>{{selectionText}}</span>
    </div>
  </div>
  {{/selectionText}}

  <!-- Definition -->
  <div id="definition" class="card-b" data-type="definition">
    <div class="dictionary-counter"></div>
    <div class="toggle-area left-larger tappable"></div>
    <div class="toggle-area right-larger tappable"></div>
    <div class="toggle-area left tappable"></div>
    <div class="toggle-area right tappable"></div>
    <div class="definition-box">
      <span>{{definition}}</span>
    </div>
  </div>

  <!-- Glossary -->
  <div id="glossary" class="card-b yomitan-glossary" data-type="glossary">
    <div class="dictionary-counter"></div>
    <div class="toggle-area left-larger tappable"></div>
    <div class="toggle-area right-larger tappable"></div>
    <div class="toggle-area left tappable"></div>
    <div class="toggle-area right tappable"></div>
    <div class="glossary-box">
      <span>{{glossary}}</span>
    </div>
  </div>

  <!-- FOOTER -->
  <div class="tags-and-links-wrapper">
    <!-- Tags -->
    <div class="tags-container"></div>

    <!-- External Links -->

    <div class="external-links">
      <!-- Youglish Japanese -->
      <a
        data-details="youglish.com"
        href="https://youglish.com/pronounce/{{text:word}}/japanese"
      >
        <img
          class="light-icon"
          src="_icon_youglish_light.png"
          style="width: 70px"
        />
        <img
          class="dark-icon"
          src="_icon_youglish_dark.png"
          style="width: 70px"
        />
      </a>
      <!-- OJAD (Pitch Accent Dictionary) -->
      <a
        data-details="ojad.gavo.t.u-tokyo.ac.jp"
        href="https://www.gavo.t.u-tokyo.ac.jp/ojad/search/index/word:{{text:word}}"
      >
        <img
          class="light-icon"
          src="_icon_ojad_light.png"
          style="width: 40px"
        />
        <img class="dark-icon" src="_icon_ojad_dark.png" style="width: 40px" />
      </a>
      <!-- Massif -->
      <a
        data-details="massif.la"
        href="https://massif.la/ja/search?q={{text:word}}"
      >
        <img class="light-icon" src="_icon_massif_light.png" />
        <img class="dark-icon" src="_icon_massif_dark.png" />
      </a>
      <!-- Bunpro -->
      <a
        data-details="bunpro.jp"
        href="https://bunpro.jp/grammar_points/{{text:word}}"
      >
        <img class="light-icon" src="_icon_bunpro_light.png" />
        <img class="dark-icon" src="_icon_bunpro_dark.png" />
      </a>
      <!-- Jpdb -->
      <a data-details="jpdb.io" href="https://jpdb.io/search?q={{text:word}}">
        <img class="light-icon" src="_icon_jpdb_lightmode.png" />
        <img class="dark-icon" src="_icon_jpdb_darkmode.png" />
      </a>

      <!-- Jisho -->
      <a data-details="jisho.org" href="https://jisho.org/search/{{text:word}}">
        <img class="light-icon" src="_icon_jisho_lightmode.png" />
        <img class="dark-icon" src="_icon_jisho_darkmode.png" />
      </a>

      <!-- Google Images -->
      <a
        data-details="image_search"
        href="https://www.bing.com/images/search?q={{text:word}}&amp;tbm=isch"
      >
        <img class="light-icon" src="_icon_image_black.svg" />
        <img class="dark-icon" src="_icon_image_white.svg" />
      </a>

      <!-- Nadeshiko -->
      <a
        data-details="nadeshiko.co"
        href="https://nadeshiko.co/search/sentence?query={{text:word}}"
      >
        <img class="light-icon" src="_icon_nadeshiko.ico" />
        <img class="dark-icon" src="_icon_nadeshiko.ico" />
      </a>

      <!-- Immersion Kit -->
      <a
        data-details="immersionkit.com"
        href="https://immersionkit.com/dictionary?keyword={{text:word}}"
      >
        <img class="light-icon" src="_icon_immersion_kit.ico" />
        <img class="dark-icon" src="_icon_immersion_kit.ico" />
      </a>
    </div>
  </div>

  <!-- Misc Info -->
  <div class="misc-info">{{miscInfo}}</div>
  <!-- /FOOTER -->

  <div id="dictionaryPreference" style="display: none">
    {{dictionaryPreference}}
  </div>
  <div id="kanji-tooltip"></div>
  <div id="grammar-tooltip"></div>
</div>
<!-- /BACK -->

<script>
  var senrenConfig = {};

  // Helper functions for shortcuts
  window.parseKeyConfig = function (configStr) {
    if (!configStr) return null;
    const parts = configStr
      .toLowerCase()
      .split(/[\s+]+/)
      .filter((p) => p);
    if (parts.length === 0) return null;

    const key = parts.pop();
    return {
      key: key,
      ctrl: parts.includes("ctrl") || parts.includes("control"),
      alt: parts.includes("alt"),
      shift: parts.includes("shift"),
      meta: parts.includes("meta") || parts.includes("cmd"),
    };
  };

  window.isKeyMatch = function (event, config) {
    if (!config) return false;
    return (
      event.key.toLowerCase() === config.key &&
      event.ctrlKey === config.ctrl &&
      event.altKey === config.alt &&
      event.shiftKey === config.shift &&
      event.metaKey === config.meta
    );
  };

  // Custom dark mode
  function darkMode() {
    const button = document.querySelector(".toggle-custom-dark-mode");
    const body = document.querySelector("html");
    const sunIcon = document.querySelector(".sun-icon");
    const moonIcon = document.querySelector(".moon-icon");

    const applyDarkMode = () => {
      const isDarkMode = localStorage.getItem("darkMode") === "enabled";
      body.classList.toggle("custom-dark-mode", isDarkMode);
      button.classList.toggle("dark-mode", isDarkMode);

      sunIcon.style.display = isDarkMode ? "inline" : "none";
      moonIcon.style.display = isDarkMode ? "none" : "inline";
    };

    requestAnimationFrame(applyDarkMode);

    if (button && !button.dataset.hasClickListener) {
      button.addEventListener("click", () => {
        const isCurrentlyDark = body.classList.contains("custom-dark-mode");
        localStorage.setItem(
          "darkMode",
          isCurrentlyDark ? "disabled" : "enabled",
        );
        requestAnimationFrame(applyDarkMode);
      });
      button.dataset.hasClickListener = "true";
    }
  }

  // Collect images from the glossary and add them to the picture container
  function collectGlossaryImages(deferred = false) {
    if (senrenConfig.collectGlossaryImages !== "true") return;

    const glossaryItems = document.querySelectorAll(
      "#glossary img, #definition img",
    );
    const pictureContainer = ELS.pictureContainer;

    if (!glossaryItems.length || !pictureContainer) return;

    if (!deferred && pictureContainer.querySelector("img")) {
      return;
    }

    const existingSrcs = new Set(
      Array.from(pictureContainer.querySelectorAll("img")).map(
        (img) => img.src,
      ),
    );

    glossaryItems.forEach((img) => {
      const src = img.src;
      if (!src || existingSrcs.has(src)) return;

      if (
        src === window.location.href ||
        src.toLowerCase().endsWith(".svg") ||
        img.closest('span[data-sc-pixiv="read-more-link"] a') ||
        img.closest(
          '[data-dictionary*="漢字でGo!"], [data-dictionary*="現代国語例解辞典"]',
        )
      ) {
        return;
      }

      existingSrcs.add(src);

      const newImg = new Image();
      newImg.src = src;
      newImg.loading = "lazy";

      newImg.onload = () => {
        const w = newImg.naturalWidth;
        const h = newImg.naturalHeight;
        const aspectRatio = w / h;

        // Skip small icons and badge-shaped images (e.g. 派生語 tags)
        if (w < 80 || h < 80 || aspectRatio > 2.2 || aspectRatio < 0.4) return;

        const finalAspectRatio = aspectRatio;

        if (
          w >= 120 &&
          h >= 180 &&
          finalAspectRatio >= 0.7 &&
          finalAspectRatio <= 1.6
        ) {
          newImg.classList.add("tappable");
        }

        pictureContainer.appendChild(newImg);
      };
    });
  }

  // Manages cycling between Selection Text, Definition, and Glossary
  function toggleDefinition() {
    const toggleAreas = document.querySelectorAll(
      ".toggle-area:not(#notes .toggle-area)",
    );
    const selectionText = ELS.selectionText;
    const definition = ELS.definition;
    const glossary = ELS.glossary;
    const allGlossaryListItems = [
      ...document.querySelectorAll(
        "#glossary > .glossary-box > span > div li[data-dictionary], #glossary > div > span > div > i",
      ),
      ...document.querySelectorAll(
        '#glossary div[style*="margin-bottom: 12px"][style*="display: flex"]',
      ),
    ];
    const dictionaryPreference =
      document.getElementById("dictionaryPreference")?.textContent.trim() || "";

    function updateBackgroundColor(element) {
      const backDiv = document.querySelector(".back");
      if (!backDiv || !element) return;

      const computed = getComputedStyle(element);
      const color = computed.getPropertyValue("--dict-color").trim();
      const rgb = computed.getPropertyValue("--dict-color-rgb").trim();

      if (color) backDiv.style.setProperty("--dict-color", color);
      if (rgb) backDiv.style.setProperty("--dict-color-rgb", rgb);
    }

    function getDictionaryName(element) {
      if (element.tagName === "LI" && element.hasAttribute("data-dictionary")) {
        return element.getAttribute("data-dictionary");
      }
      return null;
    }

    const hasSelectionText =
      !!selectionText && selectionText.textContent.trim() !== "";
    const hasDefinition = !!definition && definition.textContent.trim() !== "";
    let definitionDictName = null;

    if (hasDefinition) {
      const definitionLi = definition.querySelector(
        ".definition-box li[data-dictionary]",
      );
      if (definitionLi) {
        definitionDictName = definitionLi.getAttribute("data-dictionary");
      }
    }

    const visibleGlossaryItems = allGlossaryListItems.filter((li) => {
      const parentDiv = li.closest("div");
      if (parentDiv && parentDiv.classList.contains("ignore")) {
        return false;
      }

      if (hasDefinition && definitionDictName) {
        const glossaryDictName = getDictionaryName(li);
        if (glossaryDictName && glossaryDictName === definitionDictName) {
          return false;
        }
      }
      return true;
    });

    const currentVisibleItems = [];
    if (hasSelectionText)
      currentVisibleItems.push({
        type: "selectionText",
        element: selectionText,
        container: selectionText,
      });
    if (hasDefinition) {
      const defLi = definition.querySelector(
        ".definition-box li[data-dictionary]",
      );
      currentVisibleItems.push({
        type: "definition",
        element: defLi || definition,
        container: definition,
      });
    }

    if (visibleGlossaryItems.length > 0) {
      visibleGlossaryItems.forEach((li) => {
        currentVisibleItems.push({
          type: "glossary",
          element: li,
          container: glossary,
        });
      });
    }

    const totalVisibleItemsCount = currentVisibleItems.length;

    toggleAreas.forEach((area) => {
      if (totalVisibleItemsCount <= 1) {
        area.style.display = "none";
      } else {
        area.style.display = "";
      }
    });

    function updateCounters(activeIndex) {
      const counterText =
        totalVisibleItemsCount > 0
          ? `${activeIndex + 1} / ${totalVisibleItemsCount}`
          : "";

      [selectionText, definition, glossary].forEach((container) => {
        if (container) {
          const counterDiv = container.querySelector(".dictionary-counter");
          if (counterDiv) {
            counterDiv.textContent = "";
          }
        }
      });

      if (activeIndex !== -1 && totalVisibleItemsCount > 0) {
        const activeItem = currentVisibleItems[activeIndex];
        if (activeItem && activeItem.container) {
          const activeCounterDiv = activeItem.container.querySelector(
            ".dictionary-counter",
          );
          if (activeCounterDiv) {
            activeCounterDiv.textContent = counterText;
          }
        }
      }
    }

    function getCurrentIndex() {
      let activeIndex = -1;
      if (selectionText && selectionText.classList.contains("show")) {
        activeIndex = currentVisibleItems.findIndex(
          (item) => item.type === "selectionText",
        );
      } else if (definition && definition.classList.contains("show")) {
        activeIndex = currentVisibleItems.findIndex(
          (item) => item.type === "definition",
        );
      } else if (glossary && glossary.classList.contains("show")) {
        const currentGlossaryLi = visibleGlossaryItems.find(
          (li) => li.style.display === "block",
        );
        if (currentGlossaryLi) {
          activeIndex = currentVisibleItems.findIndex(
            (item) =>
              item.type === "glossary" && item.element === currentGlossaryLi,
          );
        } else if (
          currentVisibleItems.some((item) => item.type === "glossary")
        ) {
          activeIndex = currentVisibleItems.findIndex(
            (item) => item.type === "glossary",
          );
        }
      }
      return activeIndex;
    }

    function getDictionaryMap() {
      const map = new Map();
      allGlossaryListItems.forEach((li) => {
        const dictionaryName = getDictionaryName(li);
        if (dictionaryName) {
          map.set(dictionaryName, li);
        }
      });
      return map;
    }

    let initialIndex = -1;

    allGlossaryListItems.forEach((li) => (li.style.display = "none"));
    if (selectionText) selectionText.classList.remove("show");
    if (definition) definition.classList.remove("show");
    if (glossary) glossary.classList.remove("show");

    if (totalVisibleItemsCount > 0) {
      const permanentLastSelected = localStorage.getItem(
        "lastSelectedDictionary",
      );
      const permanentDictionaryName =
        localStorage.getItem("lastDictionaryName");
      const dictionaryMap = getDictionaryMap();
      let initialStateSet = false;

      if (!initialStateSet) {
        // Priority 1: Selection Text
        if (hasSelectionText) {
          initialIndex = currentVisibleItems.findIndex(
            (item) => item.type === "selectionText",
          );
          if (initialIndex !== -1) {
            initialStateSet = true;
          }
        }

        // Priority 2: Local Storage
        if (
          !initialStateSet &&
          permanentLastSelected === "glossary" &&
          visibleGlossaryItems.length > 0
        ) {
          let foundDictionaryFromStorage = false;
          if (
            permanentDictionaryName &&
            dictionaryMap.has(permanentDictionaryName)
          ) {
            const specificLiElement = dictionaryMap.get(
              permanentDictionaryName,
            );
            if (visibleGlossaryItems.includes(specificLiElement)) {
              initialIndex = currentVisibleItems.findIndex(
                (item) =>
                  item.type === "glossary" &&
                  item.element === specificLiElement,
              );
              if (initialIndex !== -1) {
                specificLiElement.style.display = "block";
                foundDictionaryFromStorage = true;
                initialStateSet = true;
              }
            }
          }

          // fallback
          if (!foundDictionaryFromStorage) {
            initialIndex = currentVisibleItems.findIndex(
              (item) => item.type === "glossary",
            );
            if (initialIndex !== -1) {
              currentVisibleItems[initialIndex].element.style.display = "block";
              initialStateSet = true;
            }
          }
        }

        // Priority 3: Dictionary Preference
        if (
          !initialStateSet &&
          dictionaryPreference &&
          visibleGlossaryItems.length > 0
        ) {
          const lowerCasePref = dictionaryPreference.toLowerCase();

          if (lowerCasePref === "glossary") {
            // Preference is "glossary", show the first available one
            initialIndex = currentVisibleItems.findIndex(
              (item) => item.type === "glossary",
            );
            if (initialIndex !== -1) {
              currentVisibleItems[initialIndex].element.style.display = "block";
              initialStateSet = true;
            }
          } else {
            // Preference is a specific dictionary name
            let preferredLiElement = null;

            for (const [name, li] of dictionaryMap) {
              if (name.toLowerCase().includes(lowerCasePref)) {
                preferredLiElement = li;
                break;
              }
            }

            if (
              preferredLiElement &&
              visibleGlossaryItems.includes(preferredLiElement)
            ) {
              initialIndex = currentVisibleItems.findIndex(
                (item) =>
                  item.type === "glossary" &&
                  item.element === preferredLiElement,
              );
              if (initialIndex !== -1) {
                preferredLiElement.style.display = "block";
                initialStateSet = true;
              }
            }
          }
        }

        // Priority 4: Definition
        if (!initialStateSet && hasDefinition) {
          initialIndex = currentVisibleItems.findIndex(
            (item) => item.type === "definition",
          );
          if (initialIndex !== -1) {
            initialStateSet = true;
          }
        }

        // Priority 5: Glossary
        if (!initialStateSet && visibleGlossaryItems.length > 0) {
          initialIndex = currentVisibleItems.findIndex(
            (item) => item.type === "glossary",
          );
          if (initialIndex !== -1) {
            currentVisibleItems[initialIndex].element.style.display = "block";
            initialStateSet = true;
          }
        }

        if (!initialStateSet) {
          if (currentVisibleItems.length > 0) initialIndex = 0;
        }
      }

      if (initialIndex !== -1) {
        const initialItem = currentVisibleItems[initialIndex];
        if (initialItem.container) {
          initialItem.container.classList.add("show");
          // For collapsed dictionary entries 1
          collapseDictionary(
            initialItem.container.querySelector(
              ".definition-box, .glossary-box",
            ),
          );
          // For dictionary colorizer 1
          updateBackgroundColor(initialItem.element);
        }
      }
    }

    updateCounters(initialIndex);

    const handleToggle = (direction) => {
      const currentIndex = getCurrentIndex();
      if (currentIndex === -1 || totalVisibleItemsCount <= 1) return;

      const currentItem = currentVisibleItems[currentIndex];
      if (
        currentItem.type === "selectionText" ||
        currentItem.type === "definition"
      ) {
        if (currentItem.container)
          currentItem.container.classList.remove("show");
      } else if (currentItem.type === "glossary") {
        currentItem.element.style.display = "none";
      }

      let nextIndex;
      if (direction === "right") {
        nextIndex = (currentIndex + 1) % totalVisibleItemsCount;
      } else {
        nextIndex =
          (currentIndex - 1 + totalVisibleItemsCount) % totalVisibleItemsCount;
      }

      const nextItem = currentVisibleItems[nextIndex];

      if (currentItem.type === "glossary" && nextItem.type !== "glossary") {
        if (currentItem.container)
          currentItem.container.classList.remove("show");
      }

      if (nextItem.type === "selectionText" || nextItem.type === "definition") {
        if (nextItem.container) nextItem.container.classList.add("show");
      } else if (nextItem.type === "glossary") {
        if (nextItem.container) nextItem.container.classList.add("show");
        nextItem.element.style.display = "block";
      }

      // For collapsed dictionary entries 2
      collapseDictionary(
        nextItem.container.querySelector(".definition-box, .glossary-box"),
      );
      // For collapsed dictionary colorizer 2
      updateBackgroundColor(nextItem.element);

      if (nextItem.type === "selectionText") {
        localStorage.setItem("lastSelectedDictionary", "selectionText");
        localStorage.removeItem("lastDictionaryName");
      } else if (nextItem.type === "definition") {
        localStorage.setItem("lastSelectedDictionary", "definition");
        localStorage.removeItem("lastDictionaryName");
      } else if (nextItem.type === "glossary") {
        localStorage.setItem("lastSelectedDictionary", "glossary");
        const dictionaryName = getDictionaryName(nextItem.element);
        if (dictionaryName) {
          localStorage.setItem("lastDictionaryName", dictionaryName);
        } else {
          localStorage.removeItem("lastDictionaryName");
        }
      }

      updateCounters(nextIndex);

      const backElement = document.querySelector(".back");
      if (backElement && !backElement.classList.contains("dict-toggled-once")) {
        backElement.classList.add("dict-toggled-once");
      }
    };

    toggleAreas.forEach((area) => {
      area.onclick = (e) => {
        if (totalVisibleItemsCount <= 1) return;
        if (
          area.classList.contains("right") ||
          area.classList.contains("right-larger")
        ) {
          handleToggle("right");
        } else if (
          area.classList.contains("left") ||
          area.classList.contains("left-larger")
        ) {
          handleToggle("left");
        }
      };
    });

    if (window.senrenDefinitionKeyHandler) {
      document.removeEventListener(
        "keydown",
        window.senrenDefinitionKeyHandler,
      );
    }

    window.senrenDefinitionKeyHandler = (e) => {
      if (totalVisibleItemsCount <= 1) return;
      if (e.ctrlKey || e.altKey || e.metaKey) return;
      if (
        typeof lightbox !== "undefined" &&
        lightbox.classList.contains("active")
      )
        return;
      if (document.querySelector(".notes-legend-overlay.active")) return;
      if (
        document.activeElement &&
        (document.activeElement.tagName === "INPUT" ||
          document.activeElement.tagName === "TEXTAREA")
      ) {
        return;
      }
      if (e.key === "j") {
        e.preventDefault();
        handleToggle("left");
      }
      if (e.key === "k") {
        e.preventDefault();
        handleToggle("right");
      }
    };

    document.addEventListener("keydown", window.senrenDefinitionKeyHandler);
  }

  // Enables interaction effects
  function enableInteractions() {
    function applyClickToggleEffect(
      triggerSelector,
      targetSelector,
      extraPadding = 0,
    ) {
      const trigger = document.querySelector(triggerSelector);
      const target = document.querySelector(targetSelector);

      if (trigger && target) {
        const clickable = "is-clickable";

        if (target.innerHTML.trim() !== "") {
          trigger.classList.add(clickable);
        } else {
          trigger.classList.remove(clickable);
        }
        if (trigger.dataset.hasToggleListener) return;
        trigger.dataset.hasToggleListener = "true";

        trigger.addEventListener("click", () => {
          if (!trigger.classList.contains(clickable)) {
            return;
          }

          requestAnimationFrame(() => {
            const isCollapsed = target.classList.contains("is-collapsed");

            if (isCollapsed) {
              target.classList.remove("is-collapsed");
              target.style.maxHeight =
                target.scrollHeight + extraPadding + "px";
              if (extraPadding) {
                target.style.opacity = "1";
                target.style.paddingTop = extraPadding + "px";
              }
            } else {
              target.classList.add("is-collapsed");
              target.style.maxHeight = "0";
              if (extraPadding) {
                target.style.opacity = "0";
                target.style.paddingTop = "0px";
              }
            }
          });
        });
      }
    }

    function applyHoverEffect(
      containerSelector,
      targetSelector,
      extraPadding = 0,
    ) {
      const containers = document.querySelectorAll(containerSelector);
      const target = document.querySelector(targetSelector);
      const marginTopValue = "5px";
      const isTouch = window.matchMedia("(pointer: coarse)").matches;

      if (containers.length > 0 && target) {
        containers.forEach((container) => {
          if (container.dataset.hasHoverListener) return;
          container.dataset.hasHoverListener = "true";

          if (isTouch) {
            container.classList.add("tappable");
          }

          const expand = () => {
            requestAnimationFrame(() => {
              if (target.textContent.trim() !== "") {
                target.style.maxHeight =
                  target.scrollHeight + extraPadding * 2 + "px";
                if (extraPadding) {
                  target.style.opacity = "1";
                  target.style.paddingTop = extraPadding + "px";
                  target.style.paddingBottom = extraPadding + "px";
                  target.style.marginTop = marginTopValue;
                }
              }
            });
          };

          const collapse = () => {
            requestAnimationFrame(() => {
              target.style.maxHeight = "0";
              if (extraPadding) {
                target.style.opacity = "0";
                target.style.paddingTop = "0px";
                target.style.paddingBottom = "0px";
                target.style.marginTop = "0px";
              }
            });
          };

          // Mouse Hover
          container.addEventListener("pointerenter", (e) => {
            if (e.pointerType === "mouse") expand();
          });

          container.addEventListener("pointerleave", (e) => {
            if (e.pointerType === "mouse") collapse();
          });

          // Touch Interaction
          container.addEventListener("click", (e) => {
            if (e.pointerType === "touch" || isTouch) {
              if (
                e.target.closest("a, button, .tappable") &&
                e.target.closest("a, button, .tappable") !== container
              ) {
                return;
              }

              const isCollapsed =
                !target.style.maxHeight || target.style.maxHeight === "0px";
              if (isCollapsed) {
                expand();
              } else {
                collapse();
              }
            }
          });
        });
      }
    }

    const sentenceEng = document.querySelector("#sentenceEng");

    // ============================================
    // GRAMMAR HOVER (for Related/Synonym/Antonym)
    // ============================================
    function initGrammarHover(notesBox) {
      var grammarTooltip = document.getElementById("grammar-tooltip");
      if (!grammarTooltip) return;

      var ankiConnectUrl = "http://localhost:8765";
      var grammarCache = {};
      var hideGrammarTimeout = null;

      async function ankiRequest(action, params) {
        try {
          var response = await fetch(ankiConnectUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              action: action,
              version: 6,
              params: params || {},
            }),
          });
          if (!response.ok) return null;
          var data = await response.json();
          if (data.error) return null;
          return data.result;
        } catch (e) {
          return null;
        }
      }

      // Ensure senrenAnkiRequest is available for click-to-browse
      if (!window.senrenAnkiRequest) {
        window.senrenAnkiRequest = ankiRequest;
      }

      function positionGrammarTooltip(tooltip, targetEl) {
        var back = document.querySelector(".back");
        if (!back) return;
        var targetRect = targetEl.getBoundingClientRect();
        var backRect = back.getBoundingClientRect();
        var arrowSize = 7;

        var relTop = targetRect.bottom - backRect.top;
        var relLeft = targetRect.left - backRect.left;

        tooltip.style.left = relLeft + "px";
        tooltip.style.top = relTop + "px";
        tooltip.classList.remove("tooltip-above");
        tooltip.style.setProperty(
          "--tooltip-arrow-left",
          targetRect.width / 2 + "px",
        );

        // Adjust if overflows right
        var tRect = tooltip.getBoundingClientRect();
        if (tRect.right > window.innerWidth) {
          tooltip.style.left =
            relLeft + (window.innerWidth - tRect.right - 10) + "px";
        }
        // Adjust if overflows left
        var finalLeft = parseFloat(tooltip.style.left || "0");
        if (finalLeft + backRect.left < 0) {
          tooltip.style.left = -backRect.left + 10 + "px";
        }
        // Flip above if overflows bottom
        if (tRect.bottom > window.innerHeight - 10) {
          var aboveTop =
            targetRect.top - backRect.top - tRect.height - arrowSize;
          if (aboveTop + backRect.top > 0) {
            tooltip.style.top = aboveTop + "px";
            tooltip.classList.add("tooltip-above");
          }
        }
        // Recalculate arrow position
        var fLeft = parseFloat(tooltip.style.left || "0");
        var arrowLeft =
          targetRect.left - backRect.left + targetRect.width / 2 - fLeft;
        var tWidth = tooltip.offsetWidth;
        arrowLeft = Math.max(
          arrowSize,
          Math.min(arrowLeft, tWidth - arrowSize),
        );
        tooltip.style.setProperty("--tooltip-arrow-left", arrowLeft + "px");
      }

      function hideGrammarInfo(force) {
        clearTimeout(hideGrammarTimeout);
        hideGrammarTimeout = setTimeout(
          function () {
            var overTerm = document.querySelector(".grammar-term:hover");
            var overTooltip = grammarTooltip.matches(":hover");
            if (!overTerm && !overTooltip) {
              grammarTooltip.classList.remove("active");
              grammarTooltip.style.display = "none";
            }
          },
          force ? 0 : 150,
        );
      }

      async function showGrammarInfo(termEl) {
        clearTimeout(hideGrammarTimeout);
        var term = termEl.dataset.term;
        if (!term) return;

        grammarTooltip.innerHTML =
          '<div class="grammar-tooltip-loading">Searching\u2026</div>';
        grammarTooltip.classList.add("active");
        grammarTooltip.style.display = "block";
        positionGrammarTooltip(grammarTooltip, termEl);

        if (grammarCache[term]) {
          renderGrammarResults(term, termEl);
          return;
        }

        // Search for cards with this grammar in the word field
        var query = 'note:Senren+ "word:' + term + '"';
        var noteIds = await ankiRequest("findNotes", { query: query });

        if (!noteIds || noteIds.length === 0) {
          grammarCache[term] = [];
          renderGrammarResults(term, termEl);
          return;
        }

        var notesInfo = await ankiRequest("notesInfo", { notes: noteIds });
        if (!notesInfo) {
          grammarCache[term] = [];
          renderGrammarResults(term, termEl);
          return;
        }

        // Get card types for new/review status
        var allCardIds = [];
        notesInfo.forEach(function (n) {
          if (n.cards && n.cards.length)
            allCardIds.push.apply(allCardIds, n.cards);
        });
        var cardTypeMap = {};
        if (allCardIds.length > 0) {
          var cardsInfo = await ankiRequest("cardsInfo", { cards: allCardIds });
          if (cardsInfo) {
            cardsInfo.forEach(function (c) {
              cardTypeMap[c.cardId] = c.type;
            });
          }
        }

        var results = [];
        var uniqueWords = new Set();

        notesInfo.forEach(function (note) {
          var fields = note.fields;
          if (!fields || !fields.word || !fields.word.value) return;

          var tempDiv = document.createElement("div");
          tempDiv.innerHTML = fields.word.value;
          var wordValue = (
            tempDiv.textContent ||
            tempDiv.innerText ||
            ""
          ).trim();

          if (uniqueWords.has(wordValue)) return;
          uniqueWords.add(wordValue);

          var readingHtml = "";
          var readingVal = fields.reading ? fields.reading.value : "";
          if (readingVal && readingVal.includes("<li")) {
            var tDiv = document.createElement("div");
            tDiv.innerHTML = readingVal;
            var firstLi = tDiv.querySelector("li");
            if (firstLi) readingHtml = firstLi.innerHTML;
          } else {
            readingHtml = readingVal.split(/[,\u3001\u30FB]/)[0].trim();
          }

          var sentenceVal = fields.sentence ? fields.sentence.value : "";
          var pitchVal = fields.pitch ? fields.pitch.value : "";
          var pitchPosVal = fields.pitchPosition
            ? fields.pitchPosition.value
            : "";
          var tagsVal = fields.Tags ? fields.Tags.value : "";
          var isNew = !note.cards.some(function (cid) {
            return cardTypeMap[cid] > 0;
          });

          results.push({
            word: wordValue,
            reading: readingHtml,
            sentence: sentenceVal,
            pitch: pitchVal,
            pitchPosition: pitchPosVal,
            tags: tagsVal,
            isNew: isNew,
            noteId: note.noteId,
          });
        });

        grammarCache[term] = results;
        renderGrammarResults(term, termEl);
      }

      function renderGrammarResults(term, termEl) {
        var results = grammarCache[term] || [];

        if (results.length === 0) {
          grammarTooltip.innerHTML =
            '<div class="grammar-tooltip-empty">No cards found for \u300C' +
            term +
            "\u300D</div>";
          positionGrammarTooltip(grammarTooltip, termEl);
          return;
        }

        var html = '<ul class="grammar-tooltip-list">';
        var maxItems = 5;

        results.forEach(function (item, idx) {
          var newClass = item.isNew ? "is-new-card" : "";
          var displayStyle = idx >= maxItems ? ' style="display: none;"' : "";

          // Pitch info
          var firstPitchCategory = "";
          var formattedPosition = "";
          if (item.pitchPosition) {
            var numbers = [];
            var numMatch;
            var numRegex = /\d+/g;
            while ((numMatch = numRegex.exec(item.pitchPosition)) !== null) {
              var n = parseInt(numMatch[0], 10);
              if (numbers.indexOf(n) === -1) numbers.push(n);
            }
            if (numbers.length > 0 && window.senrenGetPitchType) {
              var tempRt = null;
              if (item.reading) {
                var tDiv = document.createElement("div");
                tDiv.innerHTML = item.reading;
                var txt = tDiv.textContent || "";
                if (txt) {
                  tempRt = document.createElement("rt");
                  tempRt.textContent = txt;
                }
              }
              formattedPosition = numbers
                .map(function (num) {
                  var pt = window.senrenGetPitchType(num, tempRt);
                  pt = pt.split(",")[0].trim();
                  return (
                    '<span class="pitch-number ' + pt + '">' + num + "</span>"
                  );
                })
                .join("\u30FB");
              var types = numbers.map(function (num) {
                return window
                  .senrenGetPitchType(num, tempRt)
                  .split(",")[0]
                  .trim();
              });
              firstPitchCategory = types[0] || "";
            }
          }
          if (!firstPitchCategory) {
            firstPitchCategory = item.pitch
              ? item.pitch.split(",")[0].trim()
              : "";
          }

          var sentenceHtml = "";
          if (item.sentence) {
            var s = item.sentence.trim();
            sentenceHtml = '<div class="related-sentence">' + s + "</div>";
          }

          var clickAction =
            "onclick=\"window.senrenAnkiRequest('guiBrowse', { query: 'nid:" +
            item.noteId +
            "' })\"";

          html +=
            '<li class="' +
            newClass +
            " " +
            (firstPitchCategory || "") +
            '"' +
            displayStyle +
            ">" +
            '<div class="related-word-container pitch card-a">' +
            '<span class="pitch-info ' +
            (firstPitchCategory || "") +
            " " +
            (item.tags || "") +
            '">' +
            "<ruby>" +
            '<span class="related-word clickable-word" ' +
            clickAction +
            ">" +
            item.word +
            "</span>" +
            (item.reading ? "<rt>" + item.reading + "</rt>" : "") +
            "</ruby>" +
            (formattedPosition
              ? '<div class="position">' + formattedPosition + "</div>"
              : "") +
            "</span>" +
            "</div>" +
            sentenceHtml +
            "</li>";
        });

        html += "</ul>";

        if (results.length > maxItems) {
          html +=
            '<button class="show-more-btn">Show More (' +
            (results.length - maxItems) +
            ")</button>";
        }

        grammarTooltip.innerHTML = html;

        // Draw pitch lines if available
        if (typeof drawTooltipPitchLines === "function") {
          drawTooltipPitchLines(grammarTooltip);
        } else if (window.senrenDrawPitchLines) {
          window.senrenDrawPitchLines(grammarTooltip);
        }

        grammarTooltip.classList.add("active");
        grammarTooltip.style.display = "block";
        positionGrammarTooltip(grammarTooltip, termEl);

        var showMoreBtn = grammarTooltip.querySelector(".show-more-btn");
        if (showMoreBtn) {
          showMoreBtn.addEventListener("click", function () {
            var hidden = grammarTooltip.querySelectorAll(
              'li[style="display: none;"]',
            );
            hidden.forEach(function (el) {
              el.style.display = "";
            });
            showMoreBtn.remove();
            positionGrammarTooltip(grammarTooltip, termEl);
          });
        }

        grammarTooltip.onmouseover = function () {
          clearTimeout(hideGrammarTimeout);
        };
        grammarTooltip.onmouseout = function () {
          hideGrammarInfo();
        };
      }

      // Find Related/Synonym/Antonym section bodies and wrap terms
      var hoverableSections = notesBox.querySelectorAll(
        '.notes-section[data-section="related"] .notes-section-body, ' +
          '.notes-section[data-section="synonym"] .notes-section-body, ' +
          '.notes-section[data-section="antonym"] .notes-section-body',
      );

      hoverableSections.forEach(function (body) {
        var rawContent = body.innerHTML;
        // Split by common delimiters: full-width space, comma, ・, 、, <br>
        // but preserve the delimiters
        var parts = rawContent.split(
          /(\u3000|[,\uFF0C]\s*|\u30FB|\u3001|<br\s*\/?>)/gi,
        );
        var newHtml = "";

        parts.forEach(function (part) {
          var trimmed = part.trim();
          // Check if it's a delimiter or whitespace
          if (
            !trimmed ||
            /^(\u3000|[,\uFF0C]\s*|\u30FB|\u3001|<br\s*\/?>)$/i.test(
              part.trim(),
            )
          ) {
            newHtml += part;
          } else {
            // Strip any existing HTML tags from the term for the data attribute
            var tempDiv = document.createElement("div");
            tempDiv.innerHTML = trimmed;
            var cleanTerm = (
              tempDiv.textContent ||
              tempDiv.innerText ||
              ""
            ).trim();
            if (cleanTerm) {
              newHtml +=
                '<span class="grammar-term" data-term="' +
                cleanTerm.replace(/"/g, "&quot;") +
                '">' +
                trimmed +
                "</span>";
            } else {
              newHtml += part;
            }
          }
        });

        body.innerHTML = newHtml;

        // Attach hover events
        var terms = body.querySelectorAll(".grammar-term");
        terms.forEach(function (termEl) {
          termEl.addEventListener("mouseover", function () {
            showGrammarInfo(termEl);
          });
          termEl.addEventListener("mouseout", function () {
            hideGrammarInfo();
          });
        });
      });
    }

    // ============================================
    // NOTES SECTIONS (navigable like glossary)
    // ============================================
    (function initNotesSections() {
      try {
        const notesPanel = document.getElementById("notes");
        if (!notesPanel) return;

        const notesBox = notesPanel.querySelector(".notes-box");
        const rawSpan = notesPanel.querySelector(".notes-raw");
        if (!rawSpan) return;

        const raw = rawSpan.innerHTML;

        // Normalize block-level HTML (div, p) to <br> for consistent parsing
        var normalized = raw
          .replace(/<\/?(div|p|section|article)(?:\s[^>]*)?>\s*/gi, "<br>")
          .replace(/(<br\s*\/?>\s*){2,}/gi, "<br><br>")
          .replace(/^\s*(?:<br\s*\/?>\s*)*/i, "")
          .replace(/(?:\s*<br\s*\/?>)*\s*$/i, "");

        const sectionKeywords = [
          "About",
          "Caution",
          "Fun Fact",
          "Synonym",
          "Antonym",
          "Related",
          "Misc",
          "Structure",
          "Details",
        ];
        const testPattern = new RegExp(
          "(?:^|<br\\s*/?>|\\n)\\s*(" + sectionKeywords.join("|") + ")\\b\\.?",
          "i",
        );
        const iconMap = {
          about: "fa-circle-info",
          caution: "fa-triangle-exclamation",
          "fun fact": "fa-lightbulb",
          synonym: "fa-equals",
          antonym: "fa-right-left",
          related: "fa-link",
          misc: "fa-puzzle-piece",
          structure: "fa-cubes",
          details: "fa-tags",
        };
        const colorMap = {
          about: "var(--notes-section-about)",
          caution: "var(--notes-section-caution)",
          "fun fact": "var(--notes-section-fun-fact)",
          synonym: "var(--notes-section-synonym)",
          antonym: "var(--notes-section-antonym)",
          related: "var(--notes-section-related)",
          misc: "var(--notes-section-misc)",
          structure: "var(--notes-section-structure)",
          details: "var(--notes-section-details)",
        };

        // Sections that use card grid layout (pipe-delimited)
        const cardGridSections = ["synonym", "antonym", "related", "misc"];

        // Parse sections
        var parsedSections = [];

        if (testPattern.test(normalized)) {
          var sectionPattern = new RegExp(
            "(?:^|<br\\s*/?>|\\n)\\s*(" +
              sectionKeywords.join("|") +
              ")\\b\\.?([^]*?)(?=(?:<br\\s*/?>|\\n)\\s*(?:" +
              sectionKeywords.join("|") +
              ")\\b\\.?|$)",
            "gi",
          );
          var firstMatch = normalized.search(testPattern);
          var preamble =
            firstMatch > 0 ? normalized.substring(0, firstMatch).trim() : "";
          sectionPattern.lastIndex = 0;
          var m;
          while ((m = sectionPattern.exec(normalized)) !== null) {
            var content = (m[2] || "")
              .replace(/^[\s]*(<br\s*\/?>[\s]*)*/gi, "")
              .trim();
            content = content.replace(/(<br\s*\/?>[\s]*)*$/gi, "").trim();
            parsedSections.push({
              keyword: m[1],
              content: content,
              preamble: "",
            });
          }
          if (preamble && parsedSections.length > 0) {
            parsedSections[0].preamble = preamble;
          }
        }

        // No sections found => show normalized as single item
        if (parsedSections.length === 0) {
          parsedSections.push({
            keyword: "",
            content: normalized,
            preamble: "",
          });
        }

        // Build section elements
        var sectionEls = [];
        notesBox.innerHTML = "";

        parsedSections.forEach(function (sec, i) {
          var div = document.createElement("div");
          div.className = "notes-section-item";
          div.style.display = i === 0 ? "block" : "none";

          var html = "";
          if (sec.preamble) {
            html += '<div class="notes-preamble">' + sec.preamble + "</div>";
          }
          if (sec.keyword) {
            var key = sec.keyword.toLowerCase();
            var icon = iconMap[key] || "fa-circle-info";
            var color = colorMap[key] || colorMap.about;

            // Card grid layout for Synonym/Antonym/Related/Misc sections (pipe-delimited entries)
            if (
              cardGridSections.indexOf(key) !== -1 &&
              sec.content.indexOf("|") !== -1
            ) {
              var lines = sec.content
                .split(/<br\s*\/?>/gi)
                .filter(function (l) {
                  return l.trim();
                });

              html +=
                '<div class="notes-section notes-card-section" data-section="' +
                key +
                '" style="--section-color: ' +
                color +
                '">';
              html += '<div class="notes-card-toolbar">';
              html += '<div class="notes-section-header">';
              html += '<i class="fas ' + icon + ' notes-section-icon"></i>';
              html +=
                '<span class="notes-section-title">' + sec.keyword + "</span>";
              html += "</div>";
              html +=
                '<button class="notes-card-toggle-all tappable" data-state="expanded">Collapse All</button>';
              html += "</div>";

              html += '<div class="notes-card-grid">';
              lines.forEach(function (line) {
                var parts = line.split("|").map(function (p) {
                  return p.trim();
                });
                var rawWord = parts[0] || "";
                var meaning = parts[1] || "";
                var level = parts[2] || "";
                var desc = parts[3] || "";

                // Strip disambiguation parentheses for display: のに (Despite) → のに
                // Keep full value for Anki browse search
                var displayWord = rawWord.replace(/\s*\(.*?\)\s*$/, "").trim();

                html += '<div class="notes-card tappable">';
                html += '<div class="notes-card-top">';
                html += '<div class="notes-card-info">';
                html +=
                  '<div class="notes-card-word">' + displayWord + "</div>";
                if (meaning)
                  html +=
                    '<div class="notes-card-meaning">' + meaning + "</div>";
                if (level) {
                  html +=
                    '<div class="notes-card-badge"><i class="fas fa-times badge-icon"></i> ' +
                    level +
                    "</div>";
                }
                html += "</div>";
                html +=
                  '<span class="notes-card-link tappable" data-word="' +
                  rawWord.replace(/"/g, "&quot;") +
                  '" title="Browse in Anki"><i class="fas fa-external-link-alt"></i></span>';
                html += "</div>";
                if (desc) {
                  html += '<div class="notes-card-desc">' + desc + "</div>";
                }
                html += "</div>";
              });
              html += "</div>";
              html += "</div>";
            } else if (key === "structure") {
              // Structure section: Standard/Polite toggle
              // Convert HTML-escaped <br> to actual line breaks
              var structureContent = sec.content
                .replace(/&lt;br\s*\/?&gt;/gi, "<br>")
                .replace(/&lt;BR\s*\/?&gt;/gi, "<br>");
              var structureParts = structureContent
                .split("||")
                .map(function (p) {
                  return p.trim();
                });
              var standardContent = structureParts[0] || "";
              var politeContent =
                structureParts.length > 1 ? structureParts[1] : "";
              var hasPolite = politeContent.length > 0;

              html +=
                '<div class="notes-section notes-structure-section" data-section="structure" style="--section-color: ' +
                color +
                '">';
              html += '<div class="notes-structure-header">';
              html += '<div class="notes-section-header">';
              html += '<i class="fas ' + icon + ' notes-section-icon"></i>';
              html +=
                '<span class="notes-section-title">' + sec.keyword + "</span>";
              html += "</div>";
              if (hasPolite) {
                html += '<div class="notes-structure-toggle">';
                html +=
                  '<button class="notes-structure-btn tappable active" data-mode="standard">Standard</button>';
                html +=
                  '<button class="notes-structure-btn tappable" data-mode="polite">Polite</button>';
                html += "</div>";
              }
              html += "</div>";
              html += '<div class="notes-structure-content">';
              html +=
                '<div class="notes-structure-panel active" data-panel="standard">' +
                standardContent +
                "</div>";
              if (hasPolite) {
                html +=
                  '<div class="notes-structure-panel" data-panel="polite">' +
                  politeContent +
                  "</div>";
              }
              html += "</div>";
              html += "</div>";
            } else if (key === "details") {
              // Details section: Part of Speech / Word Type / Register / Rare Kanji
              var detailParts = sec.content.split("|").map(function (p) {
                return p.trim();
              });
              var partOfSpeech = detailParts[0] || "";
              var wordType = detailParts[1] || "";
              var register = detailParts[2] || "";
              var rareKanji = detailParts[3] || "";

              html +=
                '<div class="notes-section notes-details-section" data-section="details" style="--section-color: ' +
                color +
                '">';
              html += '<div class="notes-section-header">';
              html += '<i class="fas ' + icon + ' notes-section-icon"></i>';
              html +=
                '<span class="notes-section-title">' + sec.keyword + "</span>";
              html += "</div>";
              html += '<div class="notes-details-grid">';
              if (partOfSpeech) {
                html += '<div class="notes-details-item">';
                html +=
                  '<div class="notes-details-label">Part of Speech <button class="notes-details-info tappable" data-legend="pos" title="View legend"><i class="fas fa-info-circle"></i></button></div>';
                html +=
                  '<div class="notes-details-value">' + partOfSpeech + "</div>";
                html += "</div>";
              }
              if (wordType) {
                html += '<div class="notes-details-item">';
                html +=
                  '<div class="notes-details-label">Word Type <button class="notes-details-info tappable" data-legend="wordtype" title="View legend"><i class="fas fa-info-circle"></i></button></div>';
                html +=
                  '<div class="notes-details-value">' + wordType + "</div>";
                html += "</div>";
              }
              if (register) {
                html += '<div class="notes-details-item">';
                html +=
                  '<div class="notes-details-label">Register <button class="notes-details-info tappable" data-legend="register" title="View legend"><i class="fas fa-info-circle"></i></button></div>';
                html +=
                  '<div class="notes-details-value">' + register + "</div>";
                html += "</div>";
              }
              if (rareKanji) {
                html += '<div class="notes-details-item">';
                html +=
                  '<div class="notes-details-label">Rare Kanji <button class="notes-details-info tappable" data-legend="rarekanji" title="View legend"><i class="fas fa-info-circle"></i></button></div>';
                html +=
                  '<div class="notes-details-value notes-details-rare-kanji">';
                var kanjiParts = rareKanji
                  .split("\u30FB")
                  .map(function (k) {
                    return k.trim();
                  })
                  .filter(Boolean);
                kanjiParts.forEach(function (k) {
                  html += '<span class="rare-kanji-chip">' + k + "</span>";
                });
                html += "</div>";
                html += "</div>";
              }
              html += "</div>";
              html += "</div>";
            } else {
              // Default section rendering
              html +=
                '<div class="notes-section" data-section="' +
                key +
                '" style="--section-color: ' +
                color +
                '">';
              html += '<div class="notes-section-header">';
              html += '<i class="fas ' + icon + ' notes-section-icon"></i>';
              html +=
                '<span class="notes-section-title">' + sec.keyword + "</span>";
              html += "</div>";
              html +=
                '<div class="notes-section-body">' + sec.content + "</div>";
              html += "</div>";
            }
          } else {
            html += '<div class="notes-section-body">' + sec.content + "</div>";
          }

          div.innerHTML = html;
          notesBox.appendChild(div);
          sectionEls.push(div);
        });

        // Grammar hover for Related/Synonym/Antonym sections
        initGrammarHover(notesBox);

        // Card grid: Collapse/Expand All buttons
        notesBox
          .querySelectorAll(".notes-card-toggle-all")
          .forEach(function (btn) {
            btn.addEventListener("click", function (e) {
              e.stopPropagation();
              var section = btn.closest(".notes-card-section");
              if (!section) return;
              var descs = section.querySelectorAll(".notes-card-desc");
              var isExpanded = btn.getAttribute("data-state") === "expanded";

              descs.forEach(function (desc) {
                if (isExpanded) {
                  desc.classList.add("is-collapsed");
                } else {
                  desc.classList.remove("is-collapsed");
                }
              });

              btn.setAttribute(
                "data-state",
                isExpanded ? "collapsed" : "expanded",
              );
              btn.textContent = isExpanded ? "Expand All" : "Collapse All";

              if (!notesPanel.classList.contains("is-collapsed")) {
                notesPanel.style.maxHeight = notesPanel.scrollHeight + "px";
              }
            });
          });

        // Card grid: Individual card click to toggle description
        notesBox.querySelectorAll(".notes-card").forEach(function (card) {
          card.addEventListener("click", function (e) {
            if (e.target.closest(".notes-card-link")) return;
            var desc = card.querySelector(".notes-card-desc");
            if (!desc) return;
            desc.classList.toggle("is-collapsed");

            if (!notesPanel.classList.contains("is-collapsed")) {
              setTimeout(function () {
                notesPanel.style.maxHeight = notesPanel.scrollHeight + "px";
              }, 10);
            }
          });
        });

        // Card grid: Anki browse links
        notesBox.querySelectorAll(".notes-card-link").forEach(function (link) {
          link.addEventListener("click", function (e) {
            e.stopPropagation();
            var word = link.getAttribute("data-word");
            if (!word || !window.senrenAnkiRequest) return;

            var query = '"word:' + word + '"';

            window
              .senrenAnkiRequest("findNotes", { query: query })
              .then(function (noteIds) {
                if (noteIds && noteIds.length > 0) {
                  window.senrenAnkiRequest("guiBrowse", {
                    query: query,
                  });
                } else {
                  var origHTML = link.innerHTML;
                  link.innerHTML =
                    '<span style="font-size: 0.65rem; color: #bf616a;">Not Found</span>';
                  setTimeout(function () {
                    link.innerHTML = origHTML;
                  }, 2000);
                }
              });
          });
        });

        // Structure section: Standard/Polite toggle
        notesBox
          .querySelectorAll(".notes-structure-btn")
          .forEach(function (btn) {
            btn.addEventListener("click", function (e) {
              e.stopPropagation();
              var section = btn.closest(".notes-structure-section");
              if (!section) return;
              var mode = btn.getAttribute("data-mode");

              section
                .querySelectorAll(".notes-structure-btn")
                .forEach(function (b) {
                  b.classList.remove("active");
                });
              btn.classList.add("active");

              section
                .querySelectorAll(".notes-structure-panel")
                .forEach(function (p) {
                  p.classList.remove("active");
                });
              var target = section.querySelector(
                '.notes-structure-panel[data-panel="' + mode + '"]',
              );
              if (target) target.classList.add("active");

              if (!notesPanel.classList.contains("is-collapsed")) {
                notesPanel.style.maxHeight = notesPanel.scrollHeight + "px";
              }
            });
          });

        // Details section: Legend popup data
        var legendData = {
          pos: {
            title: "Parts of Speech",
            entries: [
              {
                term: "Expression",
                jp: "表現",
                reading: "ひょうげん",
                desc: "A set combination of words that together convey a specific meaning or grammatical function.",
              },
              {
                term: "Adjective",
                jp: "形容詞",
                reading: "けいようし",
                desc: "A word that describes or modifies a noun, expressing qualities, states, or characteristics.",
              },
              {
                term: "Adverb",
                jp: "副詞",
                reading: "ふくし",
                desc: "A word that modifies a verb, adjective, or another adverb, expressing manner, degree, or frequency.",
              },
              {
                term: "Auxiliary Verb",
                jp: "助動詞",
                reading: "じょどうし",
                desc: "Verbs that attach to other words to add grammatical meaning such as tense, negation, or politeness.",
              },
              {
                term: "Conjunctive Particle",
                jp: "接続助詞",
                reading: "せつぞくじょし",
                desc: "Suffixes or particles that connect clauses, indicating relationships like cause, condition, or contrast.",
              },
              {
                term: "Noun",
                jp: "名詞",
                reading: "めいし",
                desc: "A word that represents a person, place, thing, or concept.",
              },
              {
                term: "Particle",
                jp: "助詞",
                reading: "じょし",
                desc: "A suffix that indicates the grammatical relationship of a word within a sentence.",
              },
              {
                term: "Pronoun",
                jp: "代名詞",
                reading: "だいめいし",
                desc: "A word that takes the place of a noun, referring to people, things, or concepts.",
              },
              {
                term: "Verb",
                jp: "動詞",
                reading: "どうし",
                desc: "A word used to describe an action, state, or occurrence.",
              },
            ],
          },
          wordtype: {
            title: "Word Types",
            entries: [
              {
                term: "Abbreviation",
                desc: "A shortened form of a word or phrase.",
              },
              {
                term: "Adjectival Noun",
                desc: "A noun that functions as an adjective, typically using な to modify other nouns (な-adjective).",
              },
              {
                term: "Adjective",
                desc: "An い-adjective that directly modifies nouns and conjugates for tense and negation.",
              },
              {
                term: "Adverb",
                desc: "A word that modifies verbs, adjectives, or other adverbs.",
              },
              {
                term: "Adverb Phrase",
                desc: "A group of words functioning together as an adverb.",
              },
              {
                term: "Adverbial Particle",
                desc: "A particle that adds adverbial meaning to the word it follows.",
              },
              {
                term: "Auxiliary Verb",
                desc: "A verb that attaches to another verb to add grammatical meaning.",
              },
              {
                term: "Case Marking Particle",
                desc: "A particle that marks the grammatical role of a noun in a sentence (e.g. が, を, に).",
              },
              {
                term: "Conjunction",
                desc: "A word that connects words, phrases, or clauses together.",
              },
              {
                term: "Conjunctive Particle",
                desc: "A particle that connects clauses, indicating cause, condition, or contrast.",
              },
              {
                term: "Definite Article",
                desc: "A word that specifies a particular noun (not native to Japanese, used in comparative grammar).",
              },
              {
                term: "Demonstrative Pronoun",
                desc: "A pronoun that points to a specific thing (e.g. これ, それ, あれ).",
              },
              {
                term: "Dependent Word",
                desc: "A word that cannot stand alone and must be attached to another word.",
              },
              {
                term: "Dictionary Form",
                desc: "The base, unconjugated form of a verb as it appears in the dictionary.",
              },
              {
                term: "Indefinite Article",
                desc: "A word that refers to a non-specific noun (not native to Japanese, used in comparative grammar).",
              },
              {
                term: "Independent Word",
                desc: "A word that can stand alone and carry meaning by itself.",
              },
              {
                term: "Informal Speech",
                desc: "Casual language used in relaxed or familiar contexts.",
              },
              {
                term: "Linking Particle",
                desc: "A particle that connects elements within a sentence.",
              },
              {
                term: "Noun",
                desc: "A word representing a person, place, thing, or idea.",
              },
              {
                term: "Ordinary",
                desc: "Standard, everyday language without special formality.",
              },
              {
                term: "Personal Pronoun",
                desc: "A pronoun referring to a specific person (e.g. 私, あなた, 彼).",
              },
              {
                term: "Plural",
                desc: "A form indicating more than one of something.",
              },
              {
                term: "Possessive",
                desc: "A form indicating ownership or association.",
              },
              {
                term: "Possessive Pronoun",
                desc: "A pronoun indicating possession (e.g. 私の).",
              },
              {
                term: "Predicate",
                desc: "The part of a sentence that describes what the subject does or is.",
              },
              {
                term: "Present Simple Tense",
                desc: "The verb form expressing current or habitual actions.",
              },
              {
                term: "Pronoun",
                desc: "A word that substitutes for a noun.",
              },
              {
                term: "Question Sentence Order",
                desc: "The word order used when forming questions in Japanese.",
              },
              {
                term: "Sentence Ending Particle",
                desc: "A particle placed at the end of a sentence to add nuance (e.g. よ, ね, か).",
              },
              {
                term: "Verb",
                desc: "A word describing an action, state, or occurrence.",
              },
            ],
          },
          register: {
            title: "Register",
            entries: [
              {
                term: "Standard",
                jp: "標準語",
                reading: "ひょうじゅんご",
                desc: "The default level of formality used in everyday conversation and general writing.",
              },
              {
                term: "Formal",
                jp: "正式",
                reading: "せいしき",
                desc: "Used in official contexts, ceremonial situations, business documents, and formal speeches.",
              },
              {
                term: "Polite",
                jp: "丁寧語",
                reading: "ていねいご",
                desc: "Shows respect through polite forms (です/ます), appropriate for most social interactions.",
              },
              {
                term: "Casual",
                jp: "くだけた表現",
                reading: "",
                desc: "Informal speech used among close friends, family, or in relaxed social settings.",
              },
            ],
          },
          rarekanji: {
            title: "Rare Kanji",
            entries: [
              {
                term: "Rare Kanji",
                jp: "表外漢字",
                reading: "ひょうがいかんじ",
                desc: "Kanji not included in the Jōyō kanji list. These characters may appear in literature, names, or older texts but are uncommon in everyday modern usage.",
              },
              {
                term: "Hyōgai Kanji",
                jp: "表外漢字",
                reading: "ひょうがいかんじ",
                desc: "Characters outside the official Jōyō list, sometimes used in formal writing, classical texts, or specialized vocabulary.",
              },
              {
                term: "Variant Form",
                jp: "異体字",
                reading: "いたいじ",
                desc: "An alternative written form of a kanji that carries the same meaning and reading (e.g. 儘 and 侭).",
              },
              {
                term: "Old Form",
                jp: "旧字体",
                reading: "きゅうじたい",
                desc: "The traditional form of a kanji used before the post-war script reform (e.g. 國 → 国).",
              },
              {
                term: "Ateji",
                jp: "当て字",
                reading: "あてじ",
                desc: "Kanji assigned to a word based on phonetic reading rather than meaning.",
              },
            ],
          },
        };

        // Legend popup: create overlay lazily, show/hide
        var legendOverlay = null;

        function showLegend(type, currentValue) {
          var data = legendData[type];
          if (!data) return;
          var matchValue = (currentValue || "").trim().toLowerCase();

          if (!legendOverlay) {
            legendOverlay = document.createElement("div");
            legendOverlay.className = "notes-legend-overlay";
            legendOverlay.innerHTML =
              '<div class="notes-legend-modal">' +
              '<div class="notes-legend-header">' +
              '<span class="notes-legend-title"></span>' +
              '<button class="notes-legend-close tappable"><i class="fas fa-times"></i></button>' +
              "</div>" +
              '<div class="notes-legend-body"></div>' +
              "</div>";
            document.body.appendChild(legendOverlay);

            legendOverlay.addEventListener("click", function (e) {
              if (e.target === legendOverlay) closeLegend();
            });
            legendOverlay
              .querySelector(".notes-legend-close")
              .addEventListener("click", closeLegend);
          }

          legendOverlay.querySelector(".notes-legend-title").textContent =
            data.title;

          var bodyHtml = '<table class="notes-legend-table">';
          bodyHtml +=
            "<thead><tr><th>Term</th><th>Description</th></tr></thead>";
          bodyHtml += "<tbody>";
          data.entries.forEach(function (entry) {
            var isMatch = matchValue && entry.term.toLowerCase() === matchValue;
            bodyHtml +=
              "<tr" + (isMatch ? ' class="legend-highlight"' : "") + ">";
            bodyHtml += '<td class="notes-legend-term">';
            bodyHtml +=
              '<span class="notes-legend-term-en">' + entry.term + "</span>";
            if (entry.jp) {
              bodyHtml += '<span class="notes-legend-term-jp">' + entry.jp;
              if (entry.reading)
                bodyHtml +=
                  ' <span class="notes-legend-reading">(' +
                  entry.reading +
                  ")</span>";
              bodyHtml += "</span>";
            }
            bodyHtml += "</td>";
            bodyHtml += '<td class="notes-legend-desc">' + entry.desc + "</td>";
            bodyHtml += "</tr>";
          });
          bodyHtml += "</tbody></table>";

          legendOverlay.querySelector(".notes-legend-body").innerHTML =
            bodyHtml;
          legendOverlay.classList.add("active");

          // Scroll highlighted row into view
          var highlighted = legendOverlay.querySelector(".legend-highlight");
          if (highlighted) {
            highlighted.scrollIntoView({ block: "center", behavior: "smooth" });
          }
        }

        function closeLegend() {
          if (legendOverlay) legendOverlay.classList.remove("active");
        }

        if (window._senrenLegendKeyHandler) {
          document.removeEventListener(
            "keydown",
            window._senrenLegendKeyHandler,
          );
        }
        window._senrenLegendKeyHandler = function (e) {
          if (
            e.key === "Escape" &&
            legendOverlay &&
            legendOverlay.classList.contains("active")
          ) {
            closeLegend();
          }
        };
        document.addEventListener("keydown", window._senrenLegendKeyHandler);

        // Details section: info icon click → show legend
        notesBox
          .querySelectorAll(".notes-details-info")
          .forEach(function (btn) {
            btn.addEventListener("click", function (e) {
              e.stopPropagation();
              var type = btn.getAttribute("data-legend");
              var item = btn.closest(".notes-details-item");
              var value = item
                ? item.querySelector(".notes-details-value").textContent
                : "";
              showLegend(type, value);
            });
          });

        var totalSections = sectionEls.length;
        var currentNoteIndex = 0;

        // Counter
        var counterEl = notesPanel.querySelector(".notes-counter");
        function updateCounter() {
          if (counterEl && totalSections > 1) {
            counterEl.textContent =
              currentNoteIndex + 1 + " / " + totalSections;
            counterEl.style.display = "block";
          } else if (counterEl) {
            counterEl.style.display = "none";
          }
        }

        // Toggle areas
        var toggleAreas = notesPanel.querySelectorAll(".toggle-area");
        if (totalSections <= 1) {
          toggleAreas.forEach(function (a) {
            a.style.display = "none";
          });
        }

        function showSection(index) {
          sectionEls.forEach(function (el, i) {
            el.style.display = i === index ? "block" : "none";
          });
          currentNoteIndex = index;
          updateCounter();
          // Recalculate max-height for the panel
          if (!notesPanel.classList.contains("is-collapsed")) {
            notesPanel.style.maxHeight = notesPanel.scrollHeight + "px";
          }
        }

        function handleNoteToggle(direction) {
          if (totalSections <= 1) return;
          var next;
          if (direction === "right") {
            next = (currentNoteIndex + 1) % totalSections;
          } else {
            next = (currentNoteIndex - 1 + totalSections) % totalSections;
          }
          showSection(next);
        }

        toggleAreas.forEach(function (area) {
          area.onclick = function () {
            if (totalSections <= 1) return;
            if (
              area.classList.contains("right") ||
              area.classList.contains("right-larger")
            ) {
              handleNoteToggle("right");
            } else {
              handleNoteToggle("left");
            }
          };
        });

        // H/L navigation for notes (only when notes visible)
        if (window._senrenNotesNavHandler) {
          document.removeEventListener(
            "keydown",
            window._senrenNotesNavHandler,
          );
        }
        window._senrenNotesNavHandler = function (e) {
          if (totalSections <= 1) return;
          if (e.ctrlKey || e.altKey || e.metaKey) return;
          if (notesPanel.classList.contains("is-collapsed")) return;
          if (
            document.activeElement &&
            (document.activeElement.tagName === "INPUT" ||
              document.activeElement.tagName === "TEXTAREA")
          )
            return;
          if (
            typeof lightbox !== "undefined" &&
            lightbox.classList.contains("active")
          )
            return;
          if (document.querySelector(".notes-legend-overlay.active")) return;

          if (e.key === "h") {
            e.preventDefault();
            handleNoteToggle("left");
          }
          if (e.key === "l") {
            e.preventDefault();
            handleNoteToggle("right");
          }
        };
        document.addEventListener("keydown", window._senrenNotesNavHandler);

        updateCounter();
      } catch (err) {
        console.error("initNotesSections error:", err);
      }
    })();

    // Toggle notes expand/collapse via header button
    applyClickToggleEffect(".toggle-notes", "#notes");

    // N key to toggle notes expand/collapse
    (function () {
      var notesPanelN = document.getElementById("notes");
      if (!notesPanelN) return;

      if (window._senrenNotesToggleHandler) {
        document.removeEventListener(
          "keydown",
          window._senrenNotesToggleHandler,
        );
      }
      window._senrenNotesToggleHandler = function (e) {
        if (e.ctrlKey || e.altKey || e.metaKey) return;
        if (
          document.activeElement &&
          (document.activeElement.tagName === "INPUT" ||
            document.activeElement.tagName === "TEXTAREA")
        )
          return;
        if (
          typeof lightbox !== "undefined" &&
          lightbox.classList.contains("active")
        )
          return;
        if (document.querySelector(".notes-legend-overlay.active")) return;

        if (e.key === "n") {
          e.preventDefault();
          requestAnimationFrame(function () {
            var isCollapsed = notesPanelN.classList.contains("is-collapsed");
            if (isCollapsed) {
              notesPanelN.classList.remove("is-collapsed");
              notesPanelN.style.maxHeight = notesPanelN.scrollHeight + "px";
            } else {
              notesPanelN.classList.add("is-collapsed");
              notesPanelN.style.maxHeight = "0";
            }
          });
        }
      };
      document.addEventListener("keydown", window._senrenNotesToggleHandler);
    })();

    // Auto-expand notes if setting is true
    var notesPanel = document.getElementById("notes");
    if (notesPanel) {
      var noteExpandByDefault = senrenConfig.notesDefaultExpanded;
      if (noteExpandByDefault === "true") {
        if (notesPanel.classList.contains("is-collapsed")) {
          notesPanel.style.transition = "none";
          notesPanel.classList.remove("is-collapsed");
          notesPanel.style.maxHeight = notesPanel.scrollHeight + "px";
          requestAnimationFrame(function () {
            requestAnimationFrame(function () {
              notesPanel.style.transition = "";
            });
          });
        }
      }
    }

    if (sentenceEng) {
      const expandByDefault = senrenConfig.translationDefaultExpanded;

      if (expandByDefault === "true") {
        sentenceEng.style.transition = "none";
        sentenceEng.classList.remove("is-collapsed");
        sentenceEng.style.maxHeight = sentenceEng.scrollHeight + "px";

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            sentenceEng.style.transition = "";
          });
        });
      }
    }

    applyClickToggleEffect("#formattedSentence", "#sentenceEng");

    const isTouchDevice = window.matchMedia("(pointer: coarse)").matches;
    const pictureContainer = document.querySelector(".picture-container");
    const hasPicture =
      pictureContainer && pictureContainer.querySelector("img");
    const backdropEnabled = senrenConfig.enableBackdropLayout === "1";
    const backdropStyle = senrenConfig.backdropStyle;

    let pictureHoverTriggerSelector;

    if (backdropEnabled && backdropStyle === "0") {
      let selectors = [
        ".background-box",
        ".picture-container",
        ".sentence-container",
        ".tags-and-links-wrapper",
        ".misc-info",
      ];

      if (window.matchMedia("(max-width: 1050px)").matches) {
        selectors.unshift(".header");
      }

      pictureHoverTriggerSelector = selectors.join(", ");
    } else {
      pictureHoverTriggerSelector =
        isTouchDevice || !hasPicture ? ".background-box" : ".picture-container";
    }

    const miscExpanded = senrenConfig.miscInfoDefaultExpanded;
    const miscInfoEl = document.querySelector(".misc-info");

    if (miscInfoEl) {
      if (miscInfoEl.textContent.trim() !== "") {
        miscInfoEl.classList.add("has-content");
      } else {
        miscInfoEl.classList.remove("has-content");
      }
    }

    if (miscExpanded !== "true") {
      applyHoverEffect(pictureHoverTriggerSelector, ".misc-info", 10);
    }
  }

  // Adjusts word size based on character length
  function dynamicWordSize() {
    const wordElement = document.querySelector("#word");
    if (wordElement) {
      const wordSpan = wordElement.querySelector("span");
      if (wordSpan) {
        const rubyElement = wordSpan.querySelector("ruby");
        const content = rubyElement
          ? rubyElement.firstChild.textContent.trim()
          : wordSpan.textContent.trim();
        const contentLength = content.length;

        const classNumber = Math.min(contentLength, 9);
        wordElement.classList.add(`length-${classNumber}`);
      }
    }
  }

  // Enables NSFW options
  function nsfw() {
    if (
      senrenConfig.muteNsfwAudio !== "true" &&
      senrenConfig.blurNsfwPicture !== "true"
    )
      return;

    if (!window.IS_NSFW) return;

    if (senrenConfig.muteNsfwAudio === "true") {
      const wordAudioButton = document.querySelector(
        ".audio .soundLink, .audio .replaybutton",
      );
      if (wordAudioButton) {
        wordAudioButton.click();
      }
    }

    if (senrenConfig.blurNsfwPicture === "true") {
      document.querySelectorAll(".picture-container").forEach((container) => {
        if (container.classList.contains("nsfw")) {
          container.querySelectorAll("img").forEach((img) => {
            img.addEventListener("click", () => {
              img.classList.add("clicked");
            });
          });
        }
      });
    }
  }

  // Mutes the sentence audio playback based on CSS variables
  function muteSentence() {
    if (senrenConfig.muteSentenceAudio !== "true") return;

    const muteAudio = senrenConfig.muteSentenceAudio;

    if (muteAudio === "true") {
      const wordAudioButton = document.querySelector(
        ".audio .soundLink, .audio .replaybutton",
      );

      if (wordAudioButton) {
        wordAudioButton.click();
      }
    }
  }

  // Adds titles to dictionaries
  function dictionaryTitle() {
    let processedDictionaries = new Set();

    document.querySelectorAll(".yomitan-glossary li").forEach((li) => {
      let dictionaryName = li.getAttribute("data-dictionary");
      if (dictionaryName && !processedDictionaries.has(dictionaryName)) {
        let titleElement = document.createElement("div");
        titleElement.textContent = dictionaryName;
        titleElement.classList.add("dictionary-title");
        li.prepend(titleElement);
        processedDictionaries.add(dictionaryName);
      }
    });
  }

  // Splits tags into separate elements
  function splitTags() {
    const tagsContainer = ELS.tagsContainer;
    if (tagsContainer) {
      const tags = `{{Tags}}`.split(" ");
      const elements = tags.map((tag) => {
        const tagElem = document.createElement("div");
        tagElem.className = "tags";
        tagElem.innerText = tag;
        return tagElem;
      });
      tagsContainer.replaceChildren(...elements);
    }
  }

  // Helper function to determine pitch type
  function getPitchType(number, readingElement) {
    if (!readingElement) return "unknown";

    const firstLi = readingElement.querySelector("li");
    const targetElement = firstLi || readingElement;

    const readingText = (
      targetElement.textContent ||
      targetElement.innerText ||
      ""
    )
      .replace(/<[^>]+>/g, "")
      .replace(REGEX.COMBINING_MARK, "$1゙")
      .normalize("NFC")
      .replace(REGEX.SMALL_KANA, "")
      .replace(/[・〜～]/g, "")
      .replace(/\s+/g, "");

    const moraCount = readingText.length;

    if (moraCount === 0) {
      return "unknown";
    }

    let resultType = "unknown";
    if (number === 0) resultType = "heiban";
    if (number === 1) resultType = "atamadaka";
    if (moraCount > 1 && number === moraCount) resultType = "odaka";
    if (number > 1 && number < moraCount && resultType === "unknown") {
      resultType = "nakadaka";
    }

    return resultType;
  }
  window.senrenGetPitchType = getPitchType;

  // Format pitch accent positions and categories
  function cleanPitchPositions() {
    const positionElements = document.querySelectorAll("#position");
    const rubyElement = document.querySelector("#word > span > ruby");
    const mainWordSpan = document.querySelector("#word > span");
    const sentenceSpan = document.getElementById("formattedSentence");

    const elementsToClean = [
      mainWordSpan,
      sentenceSpan,
      rubyElement,
      ...positionElements,
    ];

    elementsToClean.forEach((element) => {
      if (!element) return;

      const classList = element.classList;
      let classToModify = "";

      classList.forEach((cls) => {
        if (cls.includes(",")) {
          classToModify = cls;
        }
      });

      if (classToModify) {
        const commaIndex = classToModify.indexOf(",");
        const newClassValue =
          commaIndex !== -1
            ? classToModify.substring(0, commaIndex).trim()
            : classToModify;
        element.classList.remove(classToModify);
        element.classList.add(newClassValue);
      }
    });
    const rtElement = rubyElement?.querySelector("rt");

    const updates = [];
    let potentialFallbackClass = null;
    let applyFallback = false;

    const hasPitchClass =
      mainWordSpan &&
      ["heiban", "atamadaka", "nakadaka", "odaka", "kifuku"].some((cls) =>
        mainWordSpan.classList.contains(cls),
      );

    positionElements.forEach((element) => {
      if (element.dataset.cleaned || !element.innerHTML.trim()) return;

      const content = element.innerHTML.trim();
      const numbers = [
        ...new Set(content.match(/\d+/g)?.map((n) => parseInt(n, 10)) || []),
      ];

      if (numbers.length === 0) return;

      if (!applyFallback && mainWordSpan && rtElement && !hasPitchClass) {
        const calculated = getPitchType(numbers[0], rtElement);
        if (calculated && calculated !== "unknown") {
          potentialFallbackClass = calculated;
          applyFallback = true;
        }
      }

      const categoriesElement = element
        .closest(".pitch")
        ?.querySelector("#categories");
      const pitchTypes = categoriesElement?.textContent.split(",") || [];

      const resolvedTypes = [];
      const newContentHTML = numbers
        .map((num, index) => {
          let pitchType =
            pitchTypes[index]?.trim() || getPitchType(num, rtElement);
          let cleanPitchType = pitchType.split(",")[0].trim();
          resolvedTypes.push(cleanPitchType);
          return `<span class="pitch-number ${cleanPitchType}">${num}</span>`;
        })
        .join("・");

      updates.push({
        element: element,
        newHTML: newContentHTML,
        catElement: categoriesElement,
        fullCat: resolvedTypes.join("<br>"),
        shortCat: resolvedTypes[0],
      });
    });

    updates.forEach((update) => {
      update.element.innerHTML = update.newHTML;
      update.element.dataset.cleaned = "true";

      if (update.catElement) {
        if (update.fullCat) {
          update.catElement.dataset.fullCategories = update.fullCat;
          update.catElement.innerHTML = update.shortCat;
          update.element.addEventListener("mouseenter", () => {
            update.catElement.innerHTML =
              update.catElement.dataset.fullCategories;
          });
        } else {
          update.catElement.dataset.fullCategories = "";
          update.catElement.innerHTML = "";
        }
      }
    });

    if (applyFallback && potentialFallbackClass) {
      mainWordSpan.classList.add(potentialFallbackClass);
      if (sentenceSpan) sentenceSpan.classList.add(potentialFallbackClass);
    }
  }

  // Highlight the target word in the furigana sentence
  function highlightFurigana() {
    const sentence = `{{sentence}}`;
    let sentenceFurigana = `{{furigana:sentenceFurigana}}`;

    if (!sentenceFurigana.trim()) {
      ELS.formattedSentence.innerHTML = sentence;
      return;
    }

    sentenceFurigana = sentenceFurigana.replace(
      /([\u3005\u4e00-\u9faf]+)\[([^\]]+)\]/g,
      "<ruby><rb>$1</rb><rt>$2</rt></ruby>",
    );

    sentenceFurigana = sentenceFurigana.replace(
      REGEX.RUBY_RT,
      "<ruby><rb>$1</rb><rt>$2</rt></ruby>",
    );

    let cleanedFurigana = sentenceFurigana
      .replace(/<ruby><rb>([。、！？！？])<\/rb><rt>.*?<\/rt><\/ruby>/g, "$1")
      .replace(/<ruby>([。、！？！？])<rt>.*?<\/rt><\/ruby>/g, "$1");

    if (
      cleanedFurigana.includes('<span class="highlight">') ||
      cleanedFurigana.includes("<b>")
    ) {
      ELS.formattedSentence.innerHTML = cleanedFurigana;
      return;
    }

    const highlightedWords = [];
    let match;
    while ((match = REGEX.HIGHLIGHT.exec(sentence)) !== null) {
      highlightedWords.push(match[1]);
    }

    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = cleanedFurigana;

    const allNodes = [];

    function collectTextAndRubyNodes(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.length > 0) {
          allNodes.push({ type: "text", node: node });
        }
      } else if (node.tagName === "RUBY") {
        allNodes.push({ type: "ruby", node: node });
      } else {
        for (let i = 0; i < node.childNodes.length; i++) {
          collectTextAndRubyNodes(node.childNodes[i]);
        }
      }
    }

    collectTextAndRubyNodes(tempDiv);

    let plainText = "";
    const nodePositions = [];

    allNodes.forEach((item) => {
      let text;
      if (item.type === "text") {
        text = item.node.textContent;
      } else {
        const rb = item.node.querySelector("rb") || item.node.firstChild;
        text = rb.textContent;
      }

      nodePositions.push({
        node: item.node,
        type: item.type,
        start: plainText.length,
        end: plainText.length + text.length,
      });

      plainText += text;
    });

    highlightedWords.forEach((word) => {
      let searchStartIndex = 0;
      let wordStart;

      while ((wordStart = plainText.indexOf(word, searchStartIndex)) !== -1) {
        const wordEnd = wordStart + word.length;

        const affectedNodes = nodePositions.filter(
          (pos) => pos.start < wordEnd && pos.end > wordStart,
        );

        affectedNodes.forEach((pos) => {
          const node = pos.node;
          if (!node.parentNode) return;

          const relativeStart = Math.max(0, wordStart - pos.start);
          let relativeEnd = Math.min(pos.end - pos.start, wordEnd - pos.start);

          if (pos.type === "ruby") {
            const rb = node.querySelector("rb") || node.firstChild;
            relativeEnd = Math.min(relativeEnd, rb.textContent.length);
          } else {
            relativeEnd = Math.min(relativeEnd, node.textContent.length);
          }

          if (pos.start >= wordStart && pos.end <= wordEnd) {
            const wrapper = document.createElement("span");
            wrapper.className = "highlight";

            if (pos.type === "ruby") {
              const clone = node.cloneNode(true);
              wrapper.appendChild(clone);
              node.parentNode.replaceChild(wrapper, node);
            } else {
              wrapper.textContent = node.textContent;
              node.parentNode.replaceChild(wrapper, node);
            }
          } else {
            if (pos.type === "ruby") {
              const ruby = node;
              const rb = ruby.querySelector("rb") || ruby.firstChild;
              const rt = ruby.querySelector("rt");
              if (!rb || !rt) return;

              const baseText = rb.textContent;
              const rtText = rt.textContent;

              let newHTML = "";

              if (relativeStart > 0) {
                const subRb = baseText.substring(0, relativeStart);
                const subRtLen = Math.round(
                  (rtText.length * relativeStart) / baseText.length,
                );
                const subRt = rtText.substring(0, subRtLen);
                newHTML += `<ruby><rb>${subRb}</rb><rt>${subRt}</rt></ruby>`;
              }

              const midRb = baseText.substring(relativeStart, relativeEnd);
              const startRtIdx = Math.round(
                (rtText.length * relativeStart) / baseText.length,
              );
              const endRtIdx = Math.round(
                (rtText.length * relativeEnd) / baseText.length,
              );
              const midRt = rtText.substring(startRtIdx, endRtIdx);

              newHTML += `<span class="highlight"><ruby><rb>${midRb}</rb><rt>${midRt}</rt></ruby></span>`;

              if (relativeEnd < baseText.length) {
                const subRb = baseText.substring(relativeEnd);
                const subRt = rtText.substring(endRtIdx);
                newHTML += `<ruby><rb>${subRb}</rb><rt>${subRt}</rt></ruby>`;
              }

              const span = document.createElement("span");
              span.innerHTML = newHTML;
              ruby.parentNode.replaceChild(span, ruby);
            } else {
              const text = node.textContent;
              const beforeText = text.substring(0, relativeStart);
              const highlightedText = text.substring(
                relativeStart,
                relativeEnd,
              );
              const afterText = text.substring(relativeEnd);

              const fragment = document.createDocumentFragment();
              if (beforeText)
                fragment.appendChild(document.createTextNode(beforeText));

              const hlSpan = document.createElement("span");
              hlSpan.className = "highlight";
              hlSpan.textContent = highlightedText;
              fragment.appendChild(hlSpan);

              if (afterText)
                fragment.appendChild(document.createTextNode(afterText));

              node.parentNode.replaceChild(fragment, node);
            }
          }
        });
        searchStartIndex = wordEnd;
      }
    });

    ELS.formattedSentence.innerHTML = tempDiv.innerHTML;
  }

  // Alternative pitch styling based on CSS variables
  function alternativePitchStyle() {
    const rootElement = document.documentElement;
    const wordElement = document.getElementById("word");
    if (wordElement) {
      const pitchStyleValue = senrenConfig.pitchStyle;
      wordElement.classList.toggle("alt", pitchStyleValue === "alt");

      const pitchColorsValue = senrenConfig.pitchColors;
      wordElement.classList.toggle("colors", pitchColorsValue === "false");
    }

    const sentenceElement = document.getElementById("formattedSentence");
    if (sentenceElement) {
      const sentenceHighlightValue = senrenConfig.sentencePitchHighlight;
      sentenceElement.classList.toggle(
        "alt-highlight",
        sentenceHighlightValue === "true",
      );
    }
  }

  // Creates downstep notation for pitch accent
  function createDownstepNotation() {
    const wordElement = ELS.word;
    if (!wordElement) return;

    const mainSpan = wordElement.querySelector(":scope > span");
    const rubyElement = mainSpan?.querySelector("ruby");
    let rtElement = rubyElement?.querySelector("rt");

    if (
      (wordElement.classList.contains("reading-is-word") ||
        (rtElement && !rtElement.textContent.trim())) &&
      rubyElement
    ) {
      const wordSpan = rubyElement.querySelector("span");
      if (wordSpan) {
        rtElement = wordSpan;
      }
    }

    if (!rtElement) {
      return;
    }

    if (rtElement.querySelector("span[style], ol, li")) {
      return;
    }

    const readingText = rtElement.textContent.trim();
    if (!readingText) {
      return;
    }

    const normalizedReading = readingText.normalize("NFC");
    const morae = normalizedReading.match(REGEX.MORA) || [];

    const moraCount = morae.length;
    if (moraCount === 0) return;

    let pitchPosition = -1;
    let pitchClass = "";
    const positionElement = ELS.position;

    const mainClasses = mainSpan.classList;
    const isOriginallyKifuku = mainClasses.contains("kifuku");
    if (mainClasses.contains("heiban")) pitchClass = "heiban";
    else if (mainClasses.contains("atamadaka")) pitchClass = "atamadaka";
    else if (mainClasses.contains("nakadaka")) pitchClass = "nakadaka";
    else if (mainClasses.contains("odaka")) pitchClass = "odaka";
    else if (isOriginallyKifuku) pitchClass = "kifuku";

    if (positionElement && positionElement.textContent.trim()) {
      const firstNumMatch = positionElement.textContent.trim().match(/\d+/);
      if (firstNumMatch) {
        pitchPosition = parseInt(firstNumMatch[0], 10);
      }
    }

    if (pitchPosition !== -1) {
      if (pitchPosition === 0) pitchClass = "heiban";
      else if (pitchPosition === 1) pitchClass = "atamadaka";
      else if (moraCount > 1 && pitchPosition === moraCount)
        pitchClass = "odaka";
      else if (moraCount > 1 && pitchPosition > 1 && pitchPosition < moraCount)
        pitchClass = "nakadaka";
      else if (moraCount > 1 && pitchPosition >= moraCount)
        pitchClass = "odaka";
      else if (moraCount === 1 && pitchPosition >= 1) pitchClass = "atamadaka";
      else {
        if (!pitchClass) pitchPosition = -1;
      }
    } else if (
      pitchClass &&
      pitchClass !== "kifuku" &&
      pitchClass !== "nakadaka"
    ) {
      if (pitchClass === "heiban") pitchPosition = 0;
      else if (pitchClass === "atamadaka") pitchPosition = 1;
      else if (pitchClass === "odaka") pitchPosition = moraCount;
    }

    if (
      pitchPosition === -1 &&
      !isOriginallyKifuku &&
      pitchClass !== "kifuku"
    ) {
      return;
    }

    let pitchPattern = [];
    for (let i = 0; i < moraCount; i++) {
      if (pitchPosition === 0) pitchPattern.push(i === 0 ? "L" : "H");
      else if (pitchPosition === 1) pitchPattern.push(i === 0 ? "H" : "L");
      else {
        if (i === 0) pitchPattern.push("L");
        else if (i < pitchPosition) pitchPattern.push("H");
        else pitchPattern.push("L");
      }
    }

    const fragment = document.createDocumentFragment();
    const container = document.createElement("span");
    container.className = "pronunciation";

    if (isOriginallyKifuku) {
      container.classList.add("kifuku");
    } else if (pitchClass) {
      container.classList.add(pitchClass);
    }

    const moraeSpans = morae.map((mora, i) => {
      const currentPitch = pitchPattern[i];
      const moraSpan = document.createElement("span");
      moraSpan.className = "pronunciation-mora";
      moraSpan.textContent = mora;
      moraSpan.dataset.pitch = currentPitch === "H" ? "high" : "low";

      if (
        currentPitch === "H" &&
        ((i + 1 < moraCount && pitchPattern[i + 1] === "L") ||
          (pitchClass === "odaka" && i === moraCount - 1))
      ) {
        moraSpan.dataset.pitchNext = "low";
      }

      const lineSpan = document.createElement("span");
      lineSpan.className = "pronunciation-mora-line";
      moraSpan.appendChild(lineSpan);
      return moraSpan;
    });

    container.append(...moraeSpans);
    rtElement.replaceChildren(container);
    rtElement.style.paddingTop = "";
    rtElement.style.marginBottom = "";
    rtElement.style.position = "";
    rtElement.style.overflow = "visible";
  }

  // Merge entries from the same dictionary
  function consolidateYomitanGlossaryEntries() {
    const glossaryOuterDiv = ELS.glossary;
    if (!glossaryOuterDiv) return;

    const glossaryBox = glossaryOuterDiv.querySelector(".glossary-box");
    if (!glossaryBox) return;

    const glossarySpan = glossaryBox.querySelector("span");
    if (!glossarySpan) return;

    if (glossarySpan.dataset.consolidated === "true") return;

    const yomitanGlossaryDivs = glossarySpan.querySelectorAll(
      "div.yomitan-glossary",
    );
    if (yomitanGlossaryDivs.length === 0) return;

    let consolidationHappened = false;

    yomitanGlossaryDivs.forEach((ygDiv) => {
      const olElement = ygDiv.querySelector("ol");
      if (!olElement) return;

      const listItems = Array.from(
        olElement.querySelectorAll("li[data-dictionary]"),
      );
      if (listItems.length === 0) return;

      const groupedItems = {};
      listItems.forEach((li) => {
        const dictName = li.getAttribute("data-dictionary");
        if (!dictName) return;

        if (!groupedItems[dictName]) {
          groupedItems[dictName] = [];
        }
        groupedItems[dictName].push(li);
      });

      Object.keys(groupedItems).forEach((dictName) => {
        const items = groupedItems[dictName];

        if (items.length > 1) {
          const firstItem = items[0];
          const consolidatedLi = firstItem.cloneNode(false);
          const fragment = document.createDocumentFragment();

          items.forEach((li, index) => {
            while (li.firstChild) {
              fragment.appendChild(li.firstChild);
            }
            if (index < items.length - 1) {
              const hr = document.createElement("hr");
              hr.className = "consolidated-entry-separator";
              fragment.appendChild(hr);
            }
          });

          consolidatedLi.appendChild(fragment);
          olElement.replaceChild(consolidatedLi, firstItem);

          for (let i = 1; i < items.length; i++) {
            olElement.removeChild(items[i]);
          }

          consolidationHappened = true;
        }
      });
    });

    if (consolidationHappened) {
      glossarySpan.dataset.consolidated = "true";
    }
  }

  // Replaces the word with its reading when the word is written only in kana
  function noDuplicateKana() {
    const wordContainer = ELS.word;
    if (!wordContainer) return;

    const rubyElement = wordContainer.querySelector("ruby");
    if (!rubyElement) return;

    const substituteSetting = senrenConfig.noDuplicateKana;
    const shouldBeEnabled = substituteSetting === "true";
    const isCurrentlyEnabled =
      wordContainer.classList.contains("reading-is-word");

    if (!shouldBeEnabled) {
      if (isCurrentlyEnabled && rubyElement.dataset.originalHtml) {
        rubyElement.innerHTML = rubyElement.dataset.originalHtml;
        delete rubyElement.dataset.originalHtml;
        wordContainer.classList.remove("reading-is-word");
      }
      return;
    }

    if (shouldBeEnabled && isCurrentlyEnabled) return;

    let fullWordText = "";
    let nodesToRemove = [];

    for (const node of rubyElement.childNodes) {
      if (node.nodeName === "RT" || node.nodeName === "RP") continue;

      if (
        node.nodeType === Node.TEXT_NODE ||
        node.nodeType === Node.ELEMENT_NODE
      ) {
        fullWordText += node.textContent;
        nodesToRemove.push(node);
      }
    }

    // Strip disambiguation parentheses: のに (Despite) → のに
    var disambigMatch = fullWordText.match(/^(.+?)\s*\(.*?\)\s*$/);
    if (disambigMatch) {
      fullWordText = disambigMatch[1].trim();
      nodesToRemove.forEach(function (node) {
        if (node.nodeType === Node.TEXT_NODE) {
          node.textContent = node.textContent.replace(/\s*\(.*?\)\s*$/, "");
        }
      });
    }

    if (!fullWordText.trim()) return;

    const hasKanji = REGEX.KANJI.test(fullWordText);

    if (!hasKanji) {
      const rtElement = rubyElement.querySelector("rt");
      if (!rtElement) return;

      let readingHTML = "";
      const firstLi = rtElement.querySelector("li");
      readingHTML = firstLi ? firstLi.innerHTML : rtElement.innerHTML;

      if (readingHTML.trim()) {
        rubyElement.dataset.originalHtml = rubyElement.innerHTML;

        const readingWrapper = document.createElement("span");
        readingWrapper.innerHTML = readingHTML;

        nodesToRemove.forEach((node) => node.remove());

        rubyElement.insertBefore(readingWrapper, rtElement);
        rtElement.style.display = "none";

        wordContainer.classList.add("reading-is-word");
      }
    }
  }

  // Collapses long dictionary entries and adds a clickable fade-out.
  function collapseDictionary(container) {
    const isCollapsedEnabled = senrenConfig.dictionaryCollapse;
    if (isCollapsedEnabled !== "1") {
      return;
    }

    if (!container || container.dataset.expanded === "true") {
      return;
    }

    const maxHeight = parseInt(senrenConfig.dictionaryMaxHeight, 10);

    const oldFade = container.querySelector(".fade-to-show-more");
    if (oldFade) oldFade.remove();
    container.classList.remove("is-collapsed");

    if (container.scrollHeight > maxHeight) {
      container.classList.add("is-collapsed");

      const fadeElement = document.createElement("div");
      fadeElement.className = "fade-to-show-more tappable";
      container.appendChild(fadeElement);

      fadeElement.addEventListener("click", (e) => {
        e.stopPropagation();
        container.classList.remove("is-collapsed");
        container.dataset.expanded = "true";
        fadeElement.remove();
      });
    }
  }

  // Groups text, audio, and images into navigable scenes
  function enableSceneSwitching() {
    if (window.currentSceneKeyHandler) {
      document.removeEventListener("keydown", window.currentSceneKeyHandler);
      window.currentSceneKeyHandler = null;
    }

    const audioContainer = ELS.audioContainer;
    const audioParts = audioContainer
      ? Array.from(audioContainer.children).filter((el) => el.tagName !== "BR")
      : [];

    if (audioParts.length <= 1) {
      return;
    }

    const baseWaitTime = 100;
    const timePerChar = 150;

    const wordEl = ELS.word;
    let charCount = 5;

    if (wordEl) {
      const rt = wordEl.querySelector("rt");
      const targetElement =
        rt && rt.querySelector("li") ? rt.querySelector("li") : rt || wordEl;

      let rawText = targetElement.textContent;
      let cleanedText = rawText.replace(REGEX.KANA_MODIFIERS, "");

      cleanedText = cleanedText.replace(
        /[ぁぃぅぇぉゃゅょゎァィゥェォャュョヮ]/g,
        "",
      );

      let effectiveCount = cleanedText.length;

      const narrowMatches = cleanedText.match(REGEX.NARROW_VOWELS);

      if (narrowMatches) {
        effectiveCount -= narrowMatches.length * 0.3;
      }

      charCount = Math.round(effectiveCount);

      if (charCount < 1) charCount = 1;
    }

    let SENTENCE_DELAY;

    const hasWordAudio = !!ELS.wordAudioBtn;

    if (!hasWordAudio) {
      SENTENCE_DELAY = 0;
    } else {
      if (charCount === 2) SENTENCE_DELAY = 550;
      else if (charCount === 3) SENTENCE_DELAY = 650;
      else if (charCount === 4) SENTENCE_DELAY = 700;
      else if (charCount === 5) SENTENCE_DELAY = 850;
      else if (charCount === 6) SENTENCE_DELAY = 1000;
      else if (charCount === 7) SENTENCE_DELAY = 1080;
      else if (charCount === 8) SENTENCE_DELAY = 1150;
      else SENTENCE_DELAY = baseWaitTime + charCount * timePerChar;
    }

    let initialPlayTimeout;

    const backContainer = ELS.back;
    let newArrows = [];

    if (backContainer) {
      let arrowLeft = backContainer.querySelector(".sentence-nav.left");
      let arrowRight = backContainer.querySelector(".sentence-nav.right");

      if (!arrowLeft) {
        arrowLeft = document.createElement("div");
        arrowLeft.className = "sentence-nav left";
        backContainer.appendChild(arrowLeft);
      }

      if (!arrowRight) {
        arrowRight = document.createElement("div");
        arrowRight.className = "sentence-nav right";
        backContainer.appendChild(arrowRight);
      }

      newArrows = [arrowLeft, arrowRight];
    } else {
      return;
    }

    // Sentence Group
    const sentenceContainer = ELS.formattedSentence;
    if (
      sentenceContainer &&
      !sentenceContainer.getAttribute("data-split-done")
    ) {
      const groupWrappers = Array.from(
        sentenceContainer.querySelectorAll(".group"),
      ).filter((el) => el.textContent.trim().length > 0);

      if (groupWrappers.length > 0) {
        const parts = groupWrappers.map((el) => el.outerHTML);
        sentenceContainer.innerHTML = "";
        parts.forEach((partHTML) => {
          const div = document.createElement("div");
          div.classList.add("split-sentence");
          div.innerHTML = partHTML;
          div.style.display = "none";
          sentenceContainer.appendChild(div);
        });
        sentenceContainer.setAttribute("data-split-done", "true");
      }
    }

    // Sentence Eng Group
    const engContainer = ELS.sentenceEng;
    if (engContainer && !engContainer.getAttribute("data-split-done")) {
      const allSpans = Array.from(engContainer.querySelectorAll("span"));
      const groupWrappers = allSpans.filter((el) => {
        return el.className.split(/\s+/).some((c) => /^group\d*$/.test(c));
      });

      if (groupWrappers.length > 0) {
        engContainer.innerHTML = "";

        groupWrappers.forEach((el) => {
          const div = document.createElement("div");
          div.classList.add("split-sentence-eng");
          div.innerHTML = el.outerHTML;
          div.style.display = "none";

          const match = el.className.match(/group(\d+)/);
          if (match) {
            div.setAttribute("data-target-index", parseInt(match[1], 10) - 1);
          }

          engContainer.appendChild(div);
        });
        engContainer.setAttribute("data-split-done", "true");
      }
    }

    // Misc Info Group
    const miscInfoContainer = ELS.miscInfo;

    if (
      miscInfoContainer &&
      !miscInfoContainer.getAttribute("data-split-done")
    ) {
      const allSpans = Array.from(miscInfoContainer.querySelectorAll("span"));
      const groupWrappers = allSpans.filter((el) => {
        return el.className.split(/\s+/).some((c) => /^group\d*$/.test(c));
      });

      if (groupWrappers.length > 0) {
        miscInfoContainer.innerHTML = "";

        groupWrappers.forEach((el) => {
          const div = document.createElement("div");
          div.classList.add("split-misc-info");
          div.innerHTML = el.outerHTML;
          div.style.display = "none";

          const match = el.className.match(/group(\d+)/);
          if (match) {
            div.setAttribute("data-target-index", parseInt(match[1], 10) - 1);
          }

          miscInfoContainer.appendChild(div);
        });
        miscInfoContainer.setAttribute("data-split-done", "true");
      }
    }

    const sentenceParts =
      ELS.formattedSentence?.querySelectorAll(".split-sentence") || [];
    const engParts =
      ELS.sentenceEng?.querySelectorAll(".split-sentence-eng") || [];
    const miscInfoParts =
      ELS.miscInfo?.querySelectorAll(".split-misc-info") || [];

    let totalSlides = 1;
    if (audioParts.length > 0) {
      totalSlides = audioParts.length;
    }

    // Picture Group — build scene-to-image mapping from group classes
    const pictureContainer = ELS.pictureContainer;
    var sceneToImageIndex = null; // null = no group classes, use original behavior
    if (
      pictureContainer &&
      !pictureContainer.getAttribute("data-picture-mapped")
    ) {
      const allChildren = Array.from(pictureContainer.children);
      const groupWrappers = allChildren.filter((el) => {
        return (
          el.className &&
          el.className.split(/\s+/).some((c) => /^group\d*$/.test(c))
        );
      });

      if (groupWrappers.length > 0) {
        // 1) Build mapping BEFORE unwrapping: scene index → image src
        var sceneToSrc = {};
        groupWrappers.forEach((wrapper) => {
          var cls = wrapper.className.match(/group(\d+)/);
          if (cls) {
            var sceneIdx = parseInt(cls[1], 10) - 1;
            var img = wrapper.querySelector("img");
            if (img) sceneToSrc[sceneIdx] = img.getAttribute("src");
          }
        });

        // 2) Unwrap: move imgs out of group spans into container directly
        var insertRef = pictureContainer.querySelector(
          ".nav-arrow, .toggle-image-visibility",
        );
        groupWrappers.forEach((wrapper) => {
          var imgs = Array.from(wrapper.querySelectorAll("img"));
          imgs.forEach((img) => {
            pictureContainer.insertBefore(img, insertRef);
          });
          wrapper.remove();
        });

        // 3) Build final mapping: scene index → image DOM index
        var allImgs = Array.from(pictureContainer.querySelectorAll("img"));
        sceneToImageIndex = {};
        for (var sceneIdx in sceneToSrc) {
          var src = sceneToSrc[sceneIdx];
          var imgIdx = allImgs.findIndex(
            (img) => img.getAttribute("src") === src,
          );
          if (imgIdx !== -1) sceneToImageIndex[sceneIdx] = imgIdx;
        }

        pictureContainer.setAttribute("data-picture-mapped", "true");
      }
    }

    let currentIndex = 0;

    function playActiveAudio() {
      if (senrenConfig.muteSentenceAudio === "true") return;
      if (audioParts.length === 0) return;

      document.querySelectorAll("audio").forEach((a) => {
        try {
          a.pause();
          a.currentTime = 0;
        } catch (e) {}
      });

      let audioToPlay = null;
      if (audioParts.length === 1) {
        audioToPlay = audioParts[0];
      } else if (audioParts[currentIndex]) {
        audioToPlay = audioParts[currentIndex];
      }

      if (audioToPlay) {
        audioToPlay.click();
      }
    }

    let replayTimeout;

    const handleSceneShortcuts = (e) => {
      if (
        document.activeElement &&
        ["INPUT", "TEXTAREA"].includes(document.activeElement.tagName)
      )
        return;
      if (document.querySelector(".notes-legend-overlay.active")) return;
      if (
        typeof lightbox !== "undefined" &&
        lightbox.classList.contains("active")
      )
        return;

      const cssVal = senrenConfig.sceneReplayShortcutKey;

      const replayConfig = parseKeyConfig(cssVal) || {
        key: "w",
        ctrl: false,
        alt: false,
        shift: false,
        meta: false,
      };

      if (isKeyMatch(e, replayConfig)) {
        e.preventDefault();
        e.stopPropagation();

        if (replayTimeout) clearTimeout(replayTimeout);
        if (typeof initialPlayTimeout !== "undefined")
          clearTimeout(initialPlayTimeout);

        document.querySelectorAll("audio").forEach((a) => {
          try {
            a.pause();
            a.currentTime = 0;
          } catch (e) {}
        });

        const wordAudioBtn = ELS.wordAudioBtn;
        if (wordAudioBtn) {
          wordAudioBtn.click();
        }

        const replayLoadOffset = 200;
        const delay = wordAudioBtn ? SENTENCE_DELAY + replayLoadOffset : 0;

        replayTimeout = setTimeout(() => {
          updateDisplay(true);
        }, delay);
      }

      if (e.ctrlKey) {
        if (e.key === "j") {
          e.preventDefault();
          e.stopPropagation();
          if (typeof initialPlayTimeout !== "undefined")
            clearTimeout(initialPlayTimeout);

          currentIndex--;
          if (currentIndex < 0) currentIndex = totalSlides - 1;
          updateDisplay(true);
        } else if (e.key === "k") {
          e.preventDefault();
          e.stopPropagation();
          if (typeof initialPlayTimeout !== "undefined")
            clearTimeout(initialPlayTimeout);

          currentIndex++;
          if (currentIndex >= totalSlides) currentIndex = 0;
          updateDisplay(true);
        }
      }
    };

    window.currentSceneKeyHandler = handleSceneShortcuts;
    document.addEventListener("keydown", handleSceneShortcuts);

    function updateDisplay(shouldPlayAudio = false) {
      const pictureContainer = ELS.pictureContainer;
      if (pictureContainer) {
        // Show the image mapped to current scene (if group classes were used)
        if (sceneToImageIndex !== null) {
          var allImgs = Array.from(pictureContainer.querySelectorAll("img"));
          if (allImgs.length > 0) {
            // Determine which image to show for this scene
            var targetImgIdx = sceneToImageIndex[currentIndex];
            if (targetImgIdx === undefined) {
              // No group assigned for this scene → show first image
              targetImgIdx = 0;
            }
            allImgs.forEach((img, i) => {
              img.style.setProperty(
                "display",
                i === targetImgIdx ? "block" : "none",
                "important",
              );
            });
          }
        } else {
          // Original behavior: index-based, fallback to first image
          const pictureParts = Array.from(pictureContainer.children).filter(
            (el) =>
              el.tagName !== "BR" &&
              !el.classList.contains("nav-arrow") &&
              !el.classList.contains("toggle-image-visibility"),
          );

          if (pictureParts.length > 0) {
            // If current scene index exceeds available images, show first image
            const targetIndex =
              currentIndex < pictureParts.length ? currentIndex : 0;
            pictureParts.forEach((part, i) => {
              const shouldShow = i === targetIndex;
              part.style.setProperty(
                "display",
                shouldShow ? "block" : "none",
                "important",
              );
            });
          }
        }
      }

      if (sentenceParts.length > 0) {
        sentenceParts.forEach((part, i) => {
          const shouldShow = sentenceParts.length === 1 || i === currentIndex;
          part.style.display = shouldShow ? "block" : "none";
        });
      }

      const mainMiscContainer = ELS.miscInfo;
      if (miscInfoParts.length > 0) {
        let isAnyChildVisible = false;

        miscInfoParts.forEach((part, i) => {
          let shouldShow = false;

          if (part.hasAttribute("data-target-index")) {
            const targetIndex = parseInt(
              part.getAttribute("data-target-index"),
              10,
            );
            shouldShow = targetIndex === currentIndex;
          } else {
            if (miscInfoParts.length === 1) {
              shouldShow = currentIndex === 0;
            } else {
              shouldShow = i === currentIndex;
            }
          }

          if (shouldShow) {
            part.style.setProperty("display", "flex", "important");
            isAnyChildVisible = true;
          } else {
            part.style.setProperty("display", "none", "important");
          }
        });

        if (mainMiscContainer) {
          const displayValue = isAnyChildVisible ? "flex" : "none";
          mainMiscContainer.style.setProperty(
            "display",
            displayValue,
            "important",
          );
        }
      } else if (mainMiscContainer) {
        if (currentIndex === 0) {
          mainMiscContainer.style.setProperty("display", "flex", "important");
        } else {
          mainMiscContainer.style.setProperty("display", "none", "important");
        }
      }

      const mainEngContainer = ELS.sentenceEng;
      if (engParts.length > 0) {
        engParts.forEach((part, i) => {
          let shouldShow = false;

          if (part.hasAttribute("data-target-index")) {
            const targetIndex = parseInt(
              part.getAttribute("data-target-index"),
              10,
            );
            shouldShow = targetIndex === currentIndex;
          } else {
            if (engParts.length === 1) {
              shouldShow = currentIndex === 0;
            } else {
              shouldShow = i === currentIndex;
            }
          }

          part.style.display = shouldShow ? "flex" : "none";
        });

        if (mainEngContainer) mainEngContainer.style.display = "flex";
      } else if (mainEngContainer) {
        mainEngContainer.style.display = currentIndex === 0 ? "flex" : "none";
      }

      if (audioParts.length > 0) {
        audioParts.forEach((btn, i) => {
          const shouldShow = audioParts.length === 1 || i === currentIndex;
          if (shouldShow) {
            btn.style.setProperty("display", "inline-block", "important");
          } else {
            btn.style.setProperty("display", "none", "important");
          }
        });
      }

      if (shouldPlayAudio) {
        playActiveAudio();
      }
    }

    newArrows.forEach((arrow) => {
      if (arrow.dataset.hasSceneListener) return;
      arrow.dataset.hasSceneListener = "true";

      arrow.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();

        if (initialPlayTimeout) clearTimeout(initialPlayTimeout);

        const direction = arrow.classList.contains("left") ? -1 : 1;
        currentIndex += direction;

        if (currentIndex >= totalSlides) {
          currentIndex = 0;
        } else if (currentIndex < 0) {
          currentIndex = totalSlides - 1;
        }

        updateDisplay(true);
      });
    });

    window.senrenRefreshScenes = () => updateDisplay(false);
    updateDisplay(false);

    const muteNsfw = senrenConfig.muteNsfwAudio;

    if (muteNsfw !== "true" || !window.IS_NSFW) {
      initialPlayTimeout = setTimeout(() => {
        playActiveAudio();
      }, SENTENCE_DELAY);
    }
  }

  // Toggle Image
  function enableImageToggle() {
    const hideBtn = ELS.pictureContainer?.querySelector(".hide-btn");
    const showBtn = document.querySelector(".header .show-btn");
    const backWrapper = ELS.back;

    if (!hideBtn || !showBtn || !backWrapper) return;

    const savedState = localStorage.getItem("senrenImageHidden");

    if (savedState === "true") {
      backWrapper.classList.add("image-removed");
      showBtn.style.setProperty("display", "flex", "important");
    } else {
      backWrapper.classList.remove("image-removed");
      showBtn.style.setProperty("display", "none", "important");
    }

    const toggle = () => {
      backWrapper.classList.toggle("image-removed");
      const isHidden = backWrapper.classList.contains("image-removed");

      localStorage.setItem("senrenImageHidden", isHidden ? "true" : "false");

      if (isHidden) {
        showBtn.style.setProperty("display", "flex", "important");
      } else {
        showBtn.style.setProperty("display", "none", "important");
      }

      dynamicCardHeight();
    };

    hideBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      toggle();
    });

    showBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      toggle();
    });
  }

  // Adjusts the height of the card to match the picture in Backdrop Layout (BG Card mode)
  function dynamicCardHeight() {
    const back = ELS.back;
    const img = ELS.pictureContainer?.querySelector("img");

    if (!back || !img) return;

    const applyHeight = () => {
      if (back.classList.contains("image-removed")) {
        back.style.removeProperty("min-height");
        return;
      }

      const enabled = senrenConfig.enableBackdropLayout;
      const dynamicHeight = senrenConfig.backdropDynamicHeight;
      const backdropStyle = senrenConfig.backdropStyle;

      const isActive =
        enabled === "1" && dynamicHeight === "1" && backdropStyle === "0";

      if (!isActive) {
        back.style.removeProperty("min-height");
        return;
      }

      if (img.offsetHeight > 0) {
        const style = window.getComputedStyle(back);
        const paddingTop = parseFloat(style.paddingTop) || 0;
        const paddingBottom = parseFloat(style.paddingBottom) || 0;
        const totalPadding = paddingTop + paddingBottom;

        const targetHeight = img.offsetHeight - totalPadding + "px";

        back.style.setProperty("min-height", targetHeight, "important");
      } else if (img.complete) {
        requestAnimationFrame(() => applyHeight());
      }
    };

    requestAnimationFrame(() => applyHeight());

    if (!window._senren_height_init) {
      window.addEventListener("resize", dynamicCardHeight);
      window._senren_height_init = true;
    }
  }

  (function () {
    window.senrenUpdateConfig = function (runLogic = false) {
      // Regex Cache
      window.REGEX = {
        MORA: /[きしちにひみりぎじぢびぴゔ][ゃゅょ]|[うくすつぬふむゆるぐずづぶゔ][ぁぃぅぇぉ]|[てで][ぃ]|[とど][ぅ]|[キシチニヒミリギジヂビピヴ][ャュョ]|[ウクスツヌフムユルグズヅブプヴ][ァィゥェォ]|[テデ][ィ]|[トド][ぅ]|[クグ][ヮ]|[フ][ォ]|[っッ]|ー|[んン]|[\u3041-\u3096\u30A1-\u4DBF\u3005\u3007]|[\u3041-\u3096\u30A1-\u30F6\u30FD\u30FE]|\S/g,
        KANJI: /[\u4E00-\u9FFF\u3400-\u4DBF\u3005\u3007]/,
        KANA_MODIFIERS: /[\s\u3099\u309A\u309B\u309C]/g,
        NARROW_VOWELS:
          /[いきしちにひみりぎじぢびぴイキシチニヒミリギジヂビピうくすつぬふむるぐずづぶぷウクスツヌフムルグズヅブプ]/g,
        DIGITS: /\d+/g,
        RUBY_RT: /<ruby>([^<]+?)<rt>(.*?)<\/rt><\/ruby>/g,
        HIGHLIGHT: /<(?:span class="highlight"|b)>(.*?)<\/(?:span|b)>/g,
        KANA_ONLY: /^[ぁ-ゖァ-ヺ゙゚ー\s]+$/,
        COMBINING_MARK: /([ぁ-ゖァ-ヺ])[\u3099\u309A]/g,
        SMALL_KANA: /[ぁぃぅぇぉゃゅょゎァィゥェォャゅョヮ]/g,
      };

      // NSFW Cache
      window.IS_NSFW = `{{Tags}}`.toLowerCase().includes("nsfw");

      // DOM Cache
      window.ELS = {
        back: document.querySelector(".back"),
        word: document.getElementById("word"),
        sentence: document.getElementById("sentence"),
        formattedSentence: document.getElementById("formattedSentence"),
        sentenceEng: document.getElementById("sentenceEng"),
        glossary: document.getElementById("glossary"),
        definition: document.getElementById("definition"),
        selectionText: document.getElementById("selectionText"),
        miscInfo: document.querySelector(".misc-info"),
        pictureContainer: document.querySelector(".picture-container"),
        tagsContainer: document.querySelector(".tags-container"),
        audioContainer: document.querySelector(".sentenceaudio"),
        position: document.getElementById("position"),
        wordAudioBtn: document.querySelector(
          ".audio .soundLink, .audio .replaybutton",
        ),
      };

      const style = getComputedStyle(document.documentElement);
      const getVar = (prop) =>
        style.getPropertyValue(prop).trim().toLowerCase();

      // Notes
      senrenConfig.notesDefaultExpanded = getVar("--notes-default-expanded");

      // Translation
      senrenConfig.translationDefaultExpanded = getVar(
        "--translation-default-expanded",
      );

      // Collect Glossary Images
      senrenConfig.collectGlossaryImages = getVar("--collect-glossary-images");

      // Backdrop Layout
      senrenConfig.enableBackdropLayout = getVar("--enable-backdrop-layout");
      senrenConfig.backdropStyle = getVar("--backdrop-style");
      senrenConfig.backdropDynamicHeight = getVar("--backdrop-dynamic-height");

      // Misc Info
      senrenConfig.miscInfoDefaultExpanded = getVar(
        "--misc-info-default-expanded",
      );

      // Audio
      senrenConfig.muteNsfwAudio = getVar("--mute-nsfw-audio");
      senrenConfig.muteSentenceAudio = getVar("--mute-sentence-audio");
      senrenConfig.blurNsfwPicture = getVar("--blur-nsfw-picture");

      // Kanji
      senrenConfig.enableKanjiHover = getVar("--enable-kanji-hover");
      senrenConfig.kanjiHoverAutoQuote = getVar("--kanji-hover-auto-quote");
      senrenConfig.noDuplicateKana = getVar("--no-duplicate-kana");

      // Dictionary
      senrenConfig.dictionaryCollapse = getVar("--dictionary-collapse");
      senrenConfig.dictionaryMaxHeight = getVar("--dictionary-max-height");

      // Keys
      senrenConfig.sceneReplayShortcutKey = getVar(
        "--scene-replay-shortcut-key",
      );
      senrenConfig.toggleSettingsKey = getVar("--toggle-settings-key");
      senrenConfig.togglePictureLightboxGridKey = getVar(
        "--toggle-picture-lightbox-grid-key",
      );
      senrenConfig.togglePictureLightboxKey = getVar(
        "--toggle-picture-lightbox-key",
      );
      senrenConfig.toggleCustomDarkModeKey = getVar(
        "--toggle-custom-dark-mode-key",
      );
      senrenConfig.toggleImageKey = getVar("--toggle-image-key");

      // Pitch
      senrenConfig.pitchStyle = getVar("--pitch-style");
      senrenConfig.pitchColors = getVar("--pitch-colors");
      senrenConfig.sentencePitchHighlight = getVar(
        "--sentence-pitch-highlight",
      );

      if (!runLogic) return;

      if (typeof window.dynamicCardHeight === "function") {
        window.dynamicCardHeight();
      }
      if (typeof window.alternativePitchStyle === "function") {
        window.alternativePitchStyle();
      }
    };

    // Initial load
    window.senrenUpdateConfig();

    window.IS_MOBILE =
      document.documentElement.classList.contains("mobile") ||
      document.body.classList.contains("mobile");

    const delayedFunctions =
      window.requestIdleCallback ||
      function (cb) {
        return setTimeout(cb, 200);
      };

    // Initializes immediate functions
    function init() {
      darkMode();
      nsfw();
      muteSentence();
      noDuplicateKana();
      splitTags();
      highlightFurigana();
      cleanPitchPositions();
      createDownstepNotation();
      dynamicWordSize();
      alternativePitchStyle();
      dictionaryTitle();
      collectGlossaryImages();
      consolidateYomitanGlossaryEntries();
      toggleDefinition();
      enableInteractions();
      enableSceneSwitching();
      enableImageToggle();

      if (!window.IS_MOBILE) {
        dynamicCardHeight();
      }
    }

    // initializes deferred functions
    function initDeferred() {
      delayedFunctions(() => {
        collectGlossaryImages(true);

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            setTimeout(() => {
              // External deferred functions
              if (window.senrenInitDeferred) {
                window.senrenInitDeferred();
              } else {
                const script = document.createElement("script");
                script.src = "_senren_deferred_v4.7.0.js";
                document.body.appendChild(script);
              }

              // Kanji hover
              if (!window.IS_MOBILE) {
                if (window.senrenInitKanjiHover) {
                  window.senrenInitKanjiHover();
                } else {
                  const script = document.createElement("script");
                  script.src = "_senren_kanji_hover_v4.7.0.js";
                  document.body.appendChild(script);
                }
              }

              // Settings
              if (window.senrenBuildMenu) {
                window.senrenBuildMenu();
              } else {
                const script = document.createElement("script");
                script.src = "_senren_settings_v4.7.0.js";
                document.body.appendChild(script);
              }
            }, 50);
          });
        });
      });
    }

    init();
    initDeferred();
  })();
</script>
